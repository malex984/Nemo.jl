\documentclass[a4paper,10pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{eucal}
\usepackage{amscd}
\usepackage{url}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{listings}
\urlstyle{sf}

\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\addtolength{\textwidth}{1.5in}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\Pee}{\mathbb{P}}
\newcommand{\EuO}{\mathcal{O}}
\newcommand{\Qbar}{\overline{\mathbb{Q}}}
\newcommand{\fn}{\hfill[Function]}
\newcommand{\macro}{\hfill[Macro]}
\newcommand{\gmp}{\hfill[GMP]}
\newcommand{\code}{\lstinline}
\newcommand{\desc}[1]{\vspace{-3mm}\begin{quote}#1\end{quote}}

\newcommand{\ljk}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\modulo}[1]{\;\left(\mbox{mod}\;#1\right)}
\newcommand{\fr}{\mathfrak}

\def\notdivides{\mathrel{\kern-3pt\not\!\kern4.5pt\bigm|}}
\def\nmid{\notdivides}
\def\nsubseteq{\mathrel{\kern-3pt\not\!\kern2.5pt\subseteq}}

\lstdefinelanguage{julia}
{
  keywordsprefix=\@,
  morekeywords={
    exit,whos,edit,load,is,isa,isequal,typeof,tuple,ntuple,uid,hash,finalizer,convert,promote,
    subtype,typemin,typemax,realmin,realmax,sizeof,eps,promote_type,method_exists,applicable,
    invoke,dlopen,dlsym,system,error,throw,assert,new,Inf,Nan,pi,im,begin,while,for,in,return,
    break,continue,macro,quote,let,if,elseif,else,try,catch,end,bitstype,ccall,do,using,module,
    import,export,importall,baremodule,immutable,local,global,const,Bool,Int,Int8,Int16,Int32,
    Int64,Uint,Uint8,Uint16,Uint32,Uint64,Float32,Float64,Complex64,Complex128,Any,Nothing,None,
    function,type,typealias,abstract
  },
  sensitive=true,
  morecomment=[l]{\#},
  morestring=[b]',
  morestring=[b]" 
}

\parindent=0pt
\parskip 4pt plus 2pt minus 2pt

%\email{goodwillhart@googlemail.com}

\title{Nemo: A computer algebra package for Julia}
\author{William B. Hart}

\begin{document}
\lstset{
  language=julia,
  keywordstyle=\bfseries\ttfamily\color[rgb]{0,0.6,0.4},
  identifierstyle=\ttfamily\color[rgb]{0,0.2,0.8},
  commentstyle=\color[rgb]{0.8,0.05,1},
  stringstyle=\color[rgb]{0.8,0.1,0.1},
  basicstyle=\ttfamily,
  showstringspaces=false,
}
\maketitle
\tableofcontents

\section{Introduction}

Nemo is a computer algebra package for the Julia programming language (\url{http://julialang.org/}).

Nemo is based on the C libraries:

\begin{enumerate}
\item FLINT (Fast Library for Number Theory) -- \url{http://flintlib.org/}
\item ANTIC (Algebraic Number Theory in Code) -- \url{http://github.com/wbhart/antic/}
\item Pari -- \url{http://pari.math.u-bordeaux.fr/}
\item Singular -- \url{http://www.singular.uni-kl.de/}
\end{enumerate}

The scope of Nemo is computer algebra in the limited sense of the term, and number theory. 

We hope that Nemo will eventually also provide access to the Gap library -- 
\url{http://www.gap-system.org/}.

\section{The Julia programming language}

Over two hundred programming languages were examined before settling on Julia as our choice for the
Nemo project.

Some statically compiled languages such as C++, D, Rust and Nimrod could have been reasonable solutions
up to a point. Languages such as Scala, Aldor and various others also have strong points.

But Julia is the only language which met all our design criteria.

\begin{enumerate}
\item Interactive REPL
\item Jit compiled
\item Fast native C/C++ interop
\item Dependent type system
\item Familiar imperative syntax
\item Open source implementation
\item Regular releases
\item Decent sized community
\item Portable to OSX, Windows, Linux, BSD 
\end{enumerate}

Julia started life in 2009 with a first public release in 2012. It's main architects are Jeff Bezanson,
Stefan Karpinski and Viral B. Shah, though there are well over 150 contributors to date.

Julia is based on the lightning fast LLVM compiler back end and just-in-time compiler. It is capable of
producing code which runs as fast as native C code.

Julia sports hundreds of contributed libraries, a package manager and even a Jupyter based graphical
interface.

Hundreds of thousands of lines of code have already been written in Julia. The language is
already used in production environments, including big data and parallel environments. The
Julia website gets over 150,000 visits a month. There are Julia users groups worldwide and
courses taught in Julia in at least Canada and the US.

Most importantly, Julia is designed by mathematicians for mathematicians.

Some of the key features of Julia are briefly discussed below.

\subsubsection{Jit compilation}

Julia uses just-in-time (JIT) compilation, which allows it to achieve C-like performance in real time
without a separate compilation cycle. Jit compilation is achieved through use of the LLVM compiler
back end.

LLVM is the 15 year old compiler infrastructure which underlies the Clang C/C++ compiler and components
of over a dozen other programming languages.

LLVM's chief architect is Chris Lattner, an Apple employee since 2005, now working on Apple's 
Swift programming language, which uses LLVM heavily. LLVM itself is reported to be used by Apple
for its IOS tool development. 

Jit compilation is ideal for mathematical code, since we generally do not care if there is a very short
delay for incremental compilation after we hit our Enter key. We care only about how fast our very large
loops will take to execute, after jit compilation has happened.

Julia combines LLVM's Jit with dynamic type inference. This is a strategy which allows one to
combine most of the benefits of a statically typed language (such as C/C++) with the flexibility
and ease of use of dynamically typed languages (such as Python, Javascript, PHP, Perl and 
Ruby).

To the greatest extent possible, Julia tries to infer the types for each function. However, it
allows code to be written without specifying types, if one should so wish. Thus, from the user's
perspective it is dynamically typed. But in many cases, exactly the same machine code results as
would come from a C compiler and hand-written C. 

\subsubsection{Interactive console}

Julia offers an interactive console, similar to Python. It can also be used from a Jupyter derivative
known as IJulia. This can be used on the web or even natively on Windows!

Julia has a console which provides Readline like functionality and offers an online help 
system.

Most importantly, Julia offers Jit compiled code at the console! You don't have to precompile
Julia statically to get C-like performance. What you type at the console executes at lightning
speed, immediately.

The console offers exception handling and recovery, pretty printing of types and values, stack 
traces, profiling and timing, the ability to disassemble the Jit compiled code, and exposes 
Julia's type inference machinery, introspection capabilities, interactive loading of modules 
and libraries (including native code) and all of the Julia language, including sophisticated 
metaprogramming features. 

\subsubsection{Foreign function interface}

Julia allows direct access to C/C++ libraries. There is also a simple mapping from C types to Julia
types, and thus complex and costly wrappers are not needed.

Any native dynamic library (such as flint) can be directly accessed from within Julia, so long
as it is in the current library path.

There is no additional overhead in accessing native C libraries from within Julia than there
would be from a native C program using that library.

\subsubsection{Dependent and parametric types}

Few languages in the world sport a decent dependent and parametric type system. If they
do, it is usually at static compile time only.

The prime example of parametric types for a computer algebraist is when creating a type for
polynomials over a ring $R$. In Julia, we can provide a type called Poly, which depends on
another type, $R$ say, specifying the ring you are working over. e.g. $R$ might be the
integers, or another polynomial ring, or a ring of matrices, etc.

Mathematics, especially algebra, is inherently dependent, meaning that Julia's dependent type system
is ideal for computer algebra.

\subsubsection{Polymorphism}
 
Julia is polymorphic, meaning that multiple functions (and operators) can have the same name. For
example, one can write separate versions of the determinant function for matrices over a ring versus
matrices over a field.

In most dynamic languages, e.g. Python, one writes a single function det(M), say, which
may then need many lines of code to sort out what kind of object we are taking the determinant of. All
of this decision code is executed at runtime and places an additional burden on the programmer. 

The Julia dispatch mechanism, on the other hand, does all of this automatically, alleviating the need
to write such decision code.

One can still write generic, catch-all functions, which work over any ring, say. But
these do not first need to delegate to a whole bunch of special cases where specialised
algorithms can be used. 

This greatly improves clarity and readability of code, as specialised versions of generic functions are
clearly delineated by their type signatures.

In addition to this, Julia allows functions to not only be overloaded by other Julia functions of the
same name when certain types of rings are passed as parameters, but one can also overload functions
and operators with highly specialised C/C++ implementations via the Julia native code interface.

\subsubsection{Abstract types and genericity}

Julia doesn't provide classes a la C++. As such, it is not possible to inherit data types. Instead
Julia achieves genericity by inheriting behaviour.

This is achieved by providing abstract types (also known as type classes).

Each type belongs to an \emph{abstract type}, which can be thought of as a collection of types that
have some common behaviour. For example, all the different native integer types in Julia belong to a
common \code{Integer} type class. Arithmetic operations and greatest common divisor functions
make sense for all of these integer types, for example.

Making all the native integer types belong to a single abstract \code{Integer} type class means that it
is possible to write a function that accepts any native integer type as input simply by specifying that
the given parameter is an \code{Integer}. That function will then accept any values whose type belongs
to \code{Integer}.

Abstract types can also belong to one another. For example, the \code{Integer} abstract type belongs to
the \code{Real} abstract type in Julia. 

To Julia this means that any type which belongs to \code{Integer} is more specific than a type which
belongs to \code{Real} but not to \code{Integer}.

This gives Julia a very powerful means of providing genericity. One can provide two versions of a
function, one which works only with an \code{Integer} and one which works with any \code{Real}.

If a machine integer is passed to such a generic function, Julia will determine the most specific
version of the function that applies. In this case the \code{Integer} version would be called.

If some other number is passed, which is not an integer, Julia falls back to the less specific version,
namely the \code{Real} version of the function.

Of course, one can also provide an even more specific implementation which only works for one specific
type, as opposed to an entire type class. Julia will take this as being even more specific and will call
this preferentially over the less specific versions of the function, if it applies.

\subsection{Gotchas with Julia}

Like all languages, Julia has some design decisions and gotchas that new users should be aware of. We
provide an incomplete list of these below.

\subsubsection{1-indexed arrays}

All Julia arrays are indexed starting with $1$, i.e. \code{A[1]} is the first entry, not \code{A[0]}.

This is a deliberate, long standing design decision in Julia. Many mathematical papers make use of
1-based indexing for matrices and the like. 

Some other computer algebra packages, such as Pari/GP make use of the same convention as Julia. 

Experience shows that it rarely takes more than a couple of days to get used to when coming from a
language that uses the other convention.

\subsubsection{Bignums}

Julia provides a built-in multiple precision integer type (using GMP). However for performance it also
provided native integer types.

In order to maximise performance, Julia doesn't automatically switch from native integers to bignums on
overflow. This means that if one starts off with native integers, the computation will only switch to
bignums if the programmer does that explicitly.

The main place this causes an issue is when using constant integers at the REPL. If the integers are
small enough to fit in a native machine word, then that is what will be used. If they are too large
an \code{Int128} will be used if that is big enough, otherwise a multiple precision \code{BigInt}
will be used. 

This means that one must tell Julia explicitly what kind of integer one wants, if the default is not
desired. This is similar to just about any statically typed language which provides bigints. The only
ways around it would be for Julia to only provide bigints and no native types, or to require type
annotation of all variables, either of which is not desirable.

\subsubsection{Supertypes of core types}

As we explained above, Julia provides native integer types, e.g. \code{Int} which belong to a single
type class \code{Integer}.

In a computer algebra system, we'd really like \code{Integer} to then belong to some more general
abstract type class, \code{RingElem} say.

Unfortunately, it is not possible to change the abstract type that Julia's own types and abstract types
belong to.

This will be a gotcha for users of Nemo: Julia integers do not belong to Nemo's \code{RingElem} abstract
type.

One way around this is to allow types to belong to a union type, \code{Union(Integer, RingElem)}. The
other way around it is simply to implement two versions of a function, one which accepts an
\code{Integer}, the other which accepts a \emph{RingElem}.

Fortunately, one often wants to treat integers much more specially than general ring elements, so this
doesn't cause too much of a problem in practice.

\subsubsection{Division operators}

The division functions in Julia are geared towards numerical, rather than algebraic, applications.

The main division operator \code{/} in Julia returns a floating point number when dividing integers
and the \code{div} function treats even the rationals as a model of the reals, so that \code{div(a, b)}
always returns the exact value $a/b$ (in the mathematical sense), truncated to the nearest whole
number in the direction of zero.

Julia also provides \code{//} for creating fraction objects, e.g. for creating rational fractions from
integers.

For algebraic operations, Nemo introduces an additional \code{divexact} function, which assumes you are
performing an exact division of two elements of a ring. We recommend using it exclusively, unless one
knows that one wants precisely the Julia behaviour.

\subsubsection{Multiple inheritance}

The abstract type hierarchy in Julia is one of its best features. It really makes the language
flexible and powerful.

However, at present it is only possible for a given type to belong to one abstract type (and
transitively to any abstract types that it in turn belongs to).

There are cases where it would be useful if types could belong to multiple abstract types, e.g.
\code{Inexact} and \code{RingElem} for elements that belong to inexact rings as opposed to exact 
rings.

There's currently no way around this in Julia, and so the abstract type hierarchy used by Nemo is
pretty basic.

Instead of having a multitude of abstract types, we rely on the existence of functions for specific
rings to determine what can be done with them.

For example, instead of having a \code{EuclideanDomainElem} abstract class for elements of a Euclidean
domain, we rely on the existence of the \code{gcd} function for specific rings that happen to be
Euclidean domains. If the \code{gcd} function doesn't exist, Julia will throw an exception if you
try to call a function on that ring that requires a greatest common divisor to be defined. This 
(mostly) works well in practice.

\subsubsection{Performance gotchas}

There are a number of cases where Julia will provide very poor performance, which often catch new
implementors unawares.

Firstly, Julia doesn't do jit compilation at the top level. If you simply type a series of isolated
statements into the REPL they will be interpreted, not jit compiled.

If you want to get good performance, you should put your code inside a function and call it. The jit
compilation happens at the function boundary and so if your code is inside a function it will
execute quickly.

Top level variables are also very slow to access in Julia. This is because they could change type at
any time and Julia can have no way to predict this. Therefore they aren't as fast as local variables
in functions. Type inference can guarantee that local variables always have the same type meaning that
faster code can result.

Julia provides the keyword \code{const} for top level constants. The value of such constants can't
subsequently be changed, but Julia can then rely on them having the same type (and value), and they do
not suffer from the same performance issues as top level variables.

\section{Installing Nemo}

There are currently two steps to installing Nemo: install Julia-0.4 and use the Julia
package system to install Nemo.

To install Julia, please refer to the installation instructions on the Julia website
(\url{http://julialang.org/}).

On Ubuntu, if you have root access, you can simply add a ppa and use apt-get. E.g. on
my system it was as follows

\begin{verbatim}
sudo add-apt-repository ppa:staticfloat/juliareleases
sudo apt-get update
sudo apt-get install julia
\end{verbatim}

Once Julia-0.4 is installed, start up Julia (type \code{julia} at the command 
line/shell prompt).

Now you can clone, build and test Nemo as follows:

\begin{verbatim}
Pkg.clone("https://github.com/wbhart/Nemo.git")
Pkg.build()
Pkg.test("Nemo")
\end{verbatim}

The tests should only take a few seconds to a minute to run per module, depending on
the speed of your machine. 

If you encounter bugs in Nemo, please report them to \url{nemo-devel@googlegroups.com}.

\section{Using Nemo}

Julia has a module system, and we use it to provide access to Nemo.

At present there is a single module, called \code{Nemo}. To import it and use all
exported functionality simply type

\begin{lstlisting}
using Nemo
\end{lstlisting}

\section{Nemo fundamentals}

Nemo provides both generic algorithms and types, and wrappers of implementations and native types
provided by various C/C++ libraries, such as Flint, Pari, Antic, etc.

For example, there are Flint polynomial types, Pari polynomials types, etc., but also a generic
polynomial type whose coefficients can be in any Nemo ring (e.g. another polynomial ring, or a residue
ring, etc.).

Many of the generic algorithms in Nemo are specialised for working over fields. For example, different
algorithms are used when computing greatest common divisors of polynomials over more general rings 
(where it makes sense) and polynomials over fields.
 
Some Nemo objects don't belong to either rings or fields, e.g. general $m\times n$ matrices belong to
matrix spaces, which are neither rings nor fields.

\subsection{Parent objects and Nemo type classes}

We call the ring or field or space that a Nemo arithmetic object belongs to, its \emph{parent}.

Parents are implemented in Nemo as objects. For example, there is an object corresponding to the ring
of integers as implemented by Flint, namely the unique parent object of type \code{FlintIntegerRing}.

A function named \code{parent} can be used to determine the parent of any arithmetic object in Nemo. In
many cases, the arithmetic objects themselves contain pointers to their parent object.

A parent can be thought of as a kind of \emph{mathematical type}. For example, elements of $\Z/5/Z$ and
elements of $\Z/7\Z$ have the same Julia type but different parents. The Julia type only encodes the
fact that we are working in a residue ring of the integers, but the parents encode the fact that we are
working in two different rings $\Z/5\Z$ and $\Z/7\Z$. One of the parent objects will contain the modulus
$5$, the other will contain the modulus $7$.

Both Nemo arithmetic objects and parent objects have types, and these types belong to various abstract
types defined by Nemo.

At the highest level of the Nemo type hierarchy are the abstract types for the parent objects, namely
\code{Collection}, \code{Ring} and \code{Field}. Corresponding to these are the abstract types for the
corresponding arithmetic objects themselves: \code{CollectionElem}, \code{RingElem}, \code{FieldElem}.

Thus, a polynomial would have a type that belonged to \code{RingElem} and its parent would have a type
that belonged to \code{Ring}.

Actually, the abstract type hierarchy is a bit richer than this. In fact we have a number of more
refined abstract types: \code{PolyElem}, \code{SeriesElem} and \code{ResidueElem} are abstract types
that all belong to \code{RingElem}; \code{FractionElem} is an abstract type that belongs to
\code{FieldElem}; and \code{MatElem} belongs to \code{CollectionElem}.

So in fact, polynomials have types that belong to \code{PolyElem} which in turn belongs to
\code{RingElem}.

\subsection{Basic integer and rational rings}

Before one can build generic rings over other rings, one needs a starting point on which to build.

For this purpose, Nemo provides wrappers of various C libraries, such as Flint and Pari, which have
implementations of basic rings such as the integers and rationals.

Nemo provides some convenient names for the parent objects for these basic rings. Thus, \code{ZZ} is
the name of the parent object for the ring of integers and \code{QQ} is the parent object for the
rationals.

Parent objects are callable in Nemo. They can be used to create objects with that parent. For example,
\code{ZZ(2)} creates the integer $2$ and \code{QQ(2, 3)} creates the rational $2/3$.

By default, Nemo makes \code{ZZ} an alias for the unique parent object of type \code{FlintIntegerRing}
and \code{QQ} is an alias for the unique parent object of type \code{FlintRationalField}.

Once we have these basic rings we can build up more generic rings with these as base.

Flint also provides other basic rings such as padic rings and finite fields. 

\subsection{Nemo domains}

As \code{ZZ} and \code{QQ} are just variables, they can be reassigned by the user. Therefore one can
change \code{ZZ} to be the unique object of type \code{PariIntegerRing} or \code{QQ} to be the unique
object of type \code{PariRationalField}. If one then builds up a generic ring over \code{ZZ} for
example, it would then be implemented using Pari integers instead of Flint integers.

In Nemo we call the underlying system that is used to implement the basic rings the \code{domain}. One
might select a different domain to the default one for performance reasons or because of the available
functionality for that domain, or maybe because one wishes to work predominantly with one package
instead of another. 

This system of domains gives the user good control over the implementation used and allows the user to
more easily tell which external library is responsible for the underlying implementation of their code.
This allows the user to more easily credit (or blame) external implementations.

Currently, for ease of use, we do allow maximal orders of number fields to be built from Antic number
fields, even though Pari provides the underlying implementation of maximal orders and their ideals. This
reflects the fact that Antic is very new and currently doesn't perform such computations.

Below we discuss each of the parent types and object types available in Nemo and list all the functions
available for each, with examples.

\section{Generic rings}

Internally, Nemo defines an abstract type for rings, with the following line of code:

\begin{lstlisting}
abstract Ring
\end{lstlisting}

You can check (or assert) that a given type belongs to \code{Ring} with the
\code{<:} operator. For example, we can check that the type of Nemo's \code{ZZ} parent object belongs
to \code{Ring}

\begin{lstlisting}
typeof(ZZ) <: Ring
\end{lstlisting}

Nemo will return \code{true}, indicating that the type of \code{ZZ} does belong to \code{Ring}.

Note that \code{<:} can only be used to determine if a type (or abstract type) belongs to an abstract
type. Thus \code{ZZ} does not belong to \code{Ring} since \code{ZZ} is not a type but a mathematical
parent object.

An element of a ring has a type that belongs to \code{RingElem}. For example, polynomials and integers
have types that belong to \code{RingElem}.

For example the following code will return true:

\begin{lstlisting}
typeof(ZZ(1)) <: RingElem
\end{lstlisting}

\subsection{Generic polynomial rings ($R[x]$) : \code|Poly\{T\}|}

Nemo has a parametric polynomial type (called \code{Poly}) for generic polynomials over
a ring $T$. There's not any need to deal directly with the \code{Poly} type, as we
provide a function \code{PolynomialRing} for constructing it.

The \code{Poly} type takes a parameter, namely the type of ring element that the
coefficients will have, e.g. if there was no special type for Flint polynomials over the
integers, the type of polynomials over the integers would be \code|Poly{fmpz}|.

Generic polynomials have parent \code{PolynomialRing}, which is also parameterised by the
type of the ring element of the polynomial coefficients, the same as the \code{Poly}
type is.

We have that \code{PolynomialRing} belongs to the \code{Ring} type class and \code{Poly}
belongs to the \code{PolyElem} type class which in turn belongs to the \code{RingElem}
type class.

To get the parent object for the coefficient ring we can call the \code{base_ring}
function. It accepts either a polynomial or a polynomial parent object.

We can also get a symbol representing the name of the variable (as it will print) of
a polynomial ring.

For example we have:

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

base_ring(S) == R
var(S) == :y
\end{lstlisting}

\subsubsection{Constructors}

Because dealing with the Julia types directly is somewhat messy, we provide a simple
function to create the parent of a polynomial in Nemo.

\begin{lstlisting}
PolynomialRing{T <: Ring}(::T, s::String)
\end{lstlisting}

\desc{This function takes a parent object which belongs to the \code|Ring| class 
(e.g. \code|T = ZZ|), specifying the ring that the polynomial coefficients are to 
belong to, and a \code{String} giving the string representation of a variable (e.g. 
\code|"x"|). It returns a tuple \code|(R, x)| consisting of the parent of the polynomial
ring being constructed, \code|R|, and the degree $1$ polynomial \code|x| in this ring.}

This is easier to understand by giving an example

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = (x^2 + 2x + 1)*y^3 + (x - 1)*y + 4x - 1
\end{lstlisting}

Notice that we can build up polynomials from the degree one polynomials \code{x} and
\code{y} returned by the calls to \code{PolynomialRing}. 

Another thing to note is that there is no reason why the variable name \code{x} has
to be the same as the string \code{"x"}. The latter is simply how \code{x} will print
when we evaluate it. Of course, in most situations it is convenient to use the same 
letter for the variable and for the string.

Once we have constructed a polynomial ring as above, we can use it to construct
polynomials of various kinds.

This is achieved by making the parent object of the polynomial ring callable. In the
following we assume that \code{S} is a parent object of a polynomial ring, e.g.
created by the following:

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
\end{lstlisting}

The parent object \code{S} is made callable in Nemo by overloading the Julia
\code{call} operator for polynomial ring parent objects. The type \code{T}
below will refer to the type of the polynomial coefficients.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Construct a polynomial of length $0$ in the given polynomial ring.}

\begin{lstlisting}
S(a::Integer)
S(a::T)
\end{lstlisting}

\desc{Construct a polynomial of length $1$ whose constant coefficient is $a$ if
$a \neq 0$, otherwise construct the zero polynomial.}

\begin{lstlisting}
S(a::Array{T, 1})
\end{lstlisting}

\desc{Construct a polynomial whose coefficients are given by the elements of the array
\code{a}, starting with the constant coefficient at index $1$. The array must be fully
initialised, otherwise an exception may result.}

\begin{lstlisting}
S(a::Poly{T})
\end{lstlisting}

\desc{Return a reference to the polynomial \code{a}.}

\begin{lstlisting}
S{R <: Ring}(a::R)
\end{lstlisting}

\desc{Try to convert the value \code{a} to the polynomial type parameterised by 
\code{T} and the symbol, if possible, and return the value, else raise an error. 
This constructor is used to coerce polynomials and coefficients from subordinate rings
up into the polynomial ring.}

\textbf{Examples.}

Here are some examples of these constructors in action. Note that we don't actually
ever need to deal with the parameterised \code{Poly} type directly.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
T, z = PolynomialRing(S, "z")

f = x^2 + y^3 + z + 1

g = S(2)

h = S(x^2 + 2x + 1)

j = T(x + 2)

k = S([x, x + 2, x^2 + 3x + 1])

l = S(k)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
degree{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the degree of the polynomial $a$. We define the degree of the zero
polynomial to be $-1$.}

\begin{lstlisting}
length{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the length of the polynomial $a$, i.e. its degree plus one.}

\begin{lstlisting}
normalise{T <: RingElem}(a::Poly{T}, len::Int)
\end{lstlisting}

\desc{Return the normalised length of the polynomial $a$ assuming its unnormalised
length is \code{len}. A polynomial is normalised if it is either length $0$ or its
leading coefficient is nonzero. This function is usually used internally.}

\begin{lstlisting}
coeff{T <: RingElem}(a::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the coefficient of the degree $n$ term of the polnomial $a$, or zero
if it has none.}

\begin{lstlisting}
lead{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the leading coefficient of the polynomial $a$, or zero if $a$ has
length $0$.}

\begin{lstlisting}
iszero{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the additive identity of the
polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
isone{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the multiplicative identity
of the polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
isgen{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the generator (variable) of the
polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
isunit{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is invertible, i.e. is of length
$1$ and has invertible constant coefficient, otherwise return \code{false}.}

\begin{lstlisting}
zero{T <: Ring}(::Type{Poly{T}})
\end{lstlisting}

\desc{Return the additive identity $0$ in the given polynomial ring.}

\begin{lstlisting}
one{T <: Ring}(::Type{Poly{T}})
\end{lstlisting}

\desc{Return the multiplicative identity $1$ in the given polynomial ring.}

\begin{lstlisting}
gen{T <: Ring}(::Type{Poly{T}})
\end{lstlisting}

\desc{Return the generator (variable) of the given polynomial ring.}

\begin{lstlisting}
canonical_unit{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Used for canonicalising fractions. The function simply returns
\code{canonical_unit} of the leading coefficient.}

\begin{lstlisting}
deepcopy{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Make a new polynomial which is arithmetically equal to $a$.}

\textbf{Examples.}

Here are some examples of the basic manipulation functions.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

a = zero(S)
b = one(S)
c = gen(S)
d = isunit(b)

f = x^2*y + 2x + 1
g = lead(f)

h = x*y^2 + (x + 1)*y + 3
j = coeff(h, 2)

if isgen(y)
   println(y, " is the generator of the ", parent(y))
end

k = isone(b)
m = iszero(a)

n = canonical_unit(-x*y + x + 1)
\end{lstlisting}

\subsubsection{Binary operators}

The following binary operators are provided for polynomials. Note that
if both operands are not in the same polynomial ring, Nemo will try to
coerce them into one of the two rings before applying the operation.

\begin{lstlisting}
+{T <: RingElem}(a::Poly{T}, b::Poly{T})
-{T <: RingElem}(a::Poly{T}, b::Poly{T})
*{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = f - g
n = f*g
p = f + g
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are faster than first coercing all
operands into the polynomial ring.

\begin{lstlisting}
*{T <: RingElem}(x::Poly{T}, y::Int)
*{T <: RingElem}(x::Poly{T}, y::fmpz)
*{T <: RingElem}(x::Int, y::Poly{T})
*{T <: RingElem}(x::fmpz, y::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the ad hoc binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)
h = g - 4
k = fmpz(5) - g
l = f*7
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={T <: RingElem}(x::Poly{T}, y::Poly{T})
\end{lstlisting}

Julia automatically provides a \code{!=} operator.

\begin{lstlisting}
isequal(x::Poly{T}, y::Poly{T})
\end{lstlisting}

\desc{Returns \code{true} if \code{x == y} and if each coefficient of \code{x}
matches the corresponding coefficient of \code{y} according to \code{isequal},
when applied recursively, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = x*y^2 + (x + 1)*y + 3

if f == g
   println("f is equal to g")
end
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following comparison operators are faster than first coercing the arguments
into one or the other ring.

\begin{lstlisting}
=={T <: RingElem}(x::Poly{T}, y::Integer)
=={T <: RingElem}(x::Integer, y::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here is an example of ad hoc comparison.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

if S(1) == 1
   println("S(1) is equal to ZZ(1)")
end
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = -f
\end{lstlisting}

\subsubsection{Truncation}

\begin{lstlisting}
truncate{T <: RingElem}(a::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial $a$ truncated to length $n$. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
mullow{T <: RingElem}(a::Poly{T}, b::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial \code{a*b} truncated to length $n$. If $n < 0$ we
throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of truncated operations.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = truncate(f, 1)
k = mullow(f, g, 4)
\end{lstlisting}

\subsubsection{Reversal}

\begin{lstlisting}
reverse{T <: RingElem}(x::Poly{T}, len::Int)
\end{lstlisting}

\desc{Return the reverse of the polynomial $x$, thought of as a polynomial of
the given length (the polynomial will be notionally truncated or padded with
zeroes before the leading term if necessary to match the specified length). 
The resulting polynomial is normalised. If \code{len} is negative we throw a
\code{DomainError()}.}

\begin{lstlisting}
reverse{T <: RingElem}(x::Poly{T})
\end{lstlisting}

\desc{Return the reverse of the polynomial $x$, i.e. the leading coefficient
of $x$ becomes the constant coefficient of the result, etc. The resulting
polynomial is normalised.}

\textbf{Examples.}

Here are some examples of reversal.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3

g = reverse(f, 7)
\end{lstlisting}

\subsubsection{Shifting}

\begin{lstlisting}
shift_left{T <: RingElem}(x::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial that results from shifting the coefficients of the
polynomial $x$ to the left by $n$ places, i.e. $f\times x^n$ where $x$ is the
generator of the polynomial ring that $f$ belongs to. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
shift_right{T <: RingElem}(x::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial that results from shifting the coefficients of the
polynomial $x$ to the right by $n$ places, i.e. by dividing $f$ by $x^n$ and
throwing away the remainder. If $n$ is greater than or equal to the length of
$x$ then the zero polynomial results. If $n < 0$ we throw a 
\code{DomainError()}.}

\textbf{Examples.}

Here are some examples of shifting.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3

g = shift_left(f, 7)
h = shift_right(f, 2)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial $a^n$. If $n < 0$ we throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = f^5
\end{lstlisting}

\subsubsection{Modular arithmetic}

When we have polynomials over residue rings or fields, we can reduce modulo
a polynomial over the base ring. In this way we can do modular arithmetic with
polynomials.

\begin{lstlisting}
mulmod{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, 
                                          b::Poly{T}, d::Poly{T})
\end{lstlisting}

\desc{Return $ab \pmod{d}$.}

\begin{lstlisting}
invmod{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, d::Poly{T})
\end{lstlisting}

\desc{Return $a^{-1} \pmod{d}$. If an impossible inverse is encountered, an
exception is thrown.}

\begin{lstlisting}
powmod{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, b::Int, 
                                                         d::Poly{T})
\end{lstlisting}

\desc{Return $a^b \pmod{d}$.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
S = ResidueRing(R, x^3 + 3x + 1)
T, y = PolynomialRing(S, "y")

f = (3*x^2 + x + 2)*y + x^2 + 1
g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1
h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1

invmod(f, g)
mulmod(f, g, h)
powmod(f, 3, h)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return $a$ divided by $b$. The result is only meaningful if the division is
exact. If $b = 0$ we throw a \code{DivideError()}. 

If \code{T} is a residue ring and the leading coefficient of $b$ is not invertible
in the \code{T}, an error will be thrown.} 

\textbf{Examples.}

Here is an example of exact division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = divexact(f*g, f)
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Poly{T}, b::T)
divexact{T <: RingElem}(a::Poly{T}, b::Integer)
\end{lstlisting}

\desc{Return $a$ divided by $b$. The result is only meaningful if the division is
exact. If $b = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = divexact(3*f, 3)
k = divexact(x*g, x)
\end{lstlisting}

\subsubsection{Euclidean division}

Over a residue ring we can define Euclidean division.

\begin{lstlisting}
mod{T <: Union(ResidueElem, FieldElem)}(f::Poly{T}, g::Poly{T})
\end{lstlisting}

\desc{Return the Euclidean remainder of $f$ divided by $g$, i.e. $r$ such 
that $a = bq + r$ for some polynomial $r$ with deg$(r) <$ deg$(b)$. If 
$g = 0$ we throw a \code{DivideError()}.}

\begin{lstlisting}
divrem{T <: Union(ResidueElem, FieldElem)}(f::Poly{T}, g::Poly{T})
\end{lstlisting}

\desc{Return the Euclidean quotient and remainder of $f$ divided by $g$, i.e.
a tuple \code{(q, r)} such that $a = bq + r$ with deg$(r) <$ deg$(b)$. If 
$g = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of Euclidean division.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)
U, y = PolynomialRing(T, "y")

f = y^3 + x*y^2 + (x + 1)*y + 3
g = (x + 1)*y^2 + (x^3 + 2x + 2)

h = mod(f, g)
q, r = divrem(f, g)
\end{lstlisting}

\subsubsection{Pseudodivision}

Given two polynomials $a, b$, pseudodivision computes polynomials $q$ and $r$
with length$(r) <$ length$(b)$ such that
$$L^d a = bq + r,$$
where $d =$ length$(a) -$ length$(b) + 1$ and $L$ is the leading coefficient
of $b$.

We call $q$ the pseudoquotient and $r$ the pseudoremainder.

\begin{lstlisting}
pseudorem{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the pseudoremainder of $a$ divided by $b$. If $b = 0$ we throw a 
\code{DivideError()}.}

\begin{lstlisting}
pseudodivrem{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return a tuple $(q, r)$ consisting of the pseudoquotient and pseudoremainder 
of $a$ divided by $b$. If $b = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of pseudodivision.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = pseudorem(f, g)
q, r = pseudodivrem(f, g)
\end{lstlisting}

Note that pseudodivision is not always useful. In general it computes a
multiple of the quotient, and for example in the case of polynomials over a
residue ring, this may lead to meaningless results in the presence of zero
divisors. For example

\begin{lstlisting}
R = ResidueRing(ZZ, 6)
S, x = PolynomialRing(R, "x")

f = 3*x^5 + x^4 + 3*x^2 + 2
g = 2*x^3 + 5*x^2 + 2*x + 2

pseudorem(f, g)
\end{lstlisting}

Here Nemo returns \code{3*x^2}, which happens to be \code{3*g} in this
ring.

\subsubsection{Content, primitive part, GCD and LCM}

When the base ring provides a \code{gcd} function we can provide numerous
GCD related functions for polynomials over that ring.

\begin{lstlisting}
content{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the content of the polynomial $a$, i.e. the greatest common divisor
of all its coefficients, if this exists.}

\begin{lstlisting}
primpart{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the primitive part of the polynomial $a$, i.e. the polynomial
divided by its content, if it exists.}

\begin{lstlisting}
gcd{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the greatest common divisor of the polynomials $a$ and $b$ if 
it exists.}

\begin{lstlisting}
lcm{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the least common multiple of the polynomials $a$ and $b$. We
define lcm$(a, b) = ab/$gcd$(a, b)$.}

We allow GCD for polynomials over residue rings, e.g. over $\Z/n\Z$, even when
the residue ring has zero divisors. However, if an impossible inverse is
encountered during the computation, due to zero divisors, we throw an error.

\begin{lstlisting}
gcdinv{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return a tuple $(g, s)$ such that $g$ is the gcd of $a$ and $b$ and $s$
and $t$ are polynomials such that $g = as + bt$. The value $g$ will be $1$ if
$a$ is invertible modulo $b$.}

\textbf{Examples.}

Here are some examples of content, primitive part and GCD.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = y^2 + x + 1

n = content(k)
p = primpart(k*(x^2 + 1))
q = gcd(k*m, l*m)
r = lcm(k*m, l*m)

R, x = PolynomialRing(QQ, "x")
T = ResidueRing(R, x^3 + 3x + 1)
U, z = PolynomialRing(T, "z")

r = z^3 + 2z + 1
s = z^5 + 1
u, v = gcdinv(r, s)
\end{lstlisting}

\subsubsection{Evaluation}

\begin{lstlisting}
evaluate{T <: RingElem}(a::Poly{T}, b::T)
evaluate{T <: RingElem}(a::Poly{T}, b::Integer)
evaluate{T <: RingElem}(a::Poly{T}, b::fmpz)
\end{lstlisting}

\desc{Return the value of the polynomial $a$ evaluated at $b$.}

\textbf{Examples.}

Here are some examples of evaluation.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = evaluate(f, 3)
h = evaluate(f, x^2 + 2x + 1)
\end{lstlisting}

\subsubsection{Composition}

\begin{lstlisting}
compose{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the composition of the polynomial $a$ with $b$, i.e. $a \circ b$.}

\textbf{Examples.}

Here are some examples of composition.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)
h = compose(f, g)
\end{lstlisting}

\subsubsection{Derivative}

\begin{lstlisting}
derivative{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the derivative of the polynomial $a$ with respect to its main
variable.}

\textbf{Examples.}

Here are some examples of computing derivatives.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

h = x*y^2 + (x + 1)*y + 3
j = derivative(h)
\end{lstlisting}

\subsubsection{Integral}

\begin{lstlisting}
integral{T <: Union(ResidueElem, FieldElem)}(f::Poly{T})
\end{lstlisting}

\desc{Return the integral of the polynomial $f$. The constant coefficient of
the result is taken to be $0$.}

\textbf{Examples.}

Here are some examples of computing integrals.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
S = ResidueRing(R, x^3 + 3x + 1)
T, y = PolynomialRing(S, "y")

f = (x^2 + 2x + 1)*y^2 + (x + 1)*y - 2x + 4

g = integral(f)   
\end{lstlisting}

\subsubsection{Resultant}

\begin{lstlisting}
resultant{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the resultant of the polynomials $a$ and $b$.}

\textbf{Examples.}

Here are some examples of computing resultants.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 3x*y^2 + (x + 1)*y + 3
g = 6(x + 1)*y + (x^3 + 2x + 2)
h = resultant(f, g)
\end{lstlisting}

\subsubsection{Discriminant}

\begin{lstlisting}
discriminant{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Compute the discriminant of the polynomial $a$.}

\textbf{Examples.}

Here are some examples of computing discriminants.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = discriminant(f)
\end{lstlisting}

\subsubsection{Bezout identity}

The Bezout identity is the equivalent, for polynomials, of the extended GCD
in the case of the integers.

Given polynomials $a, b$, we can find polynomials $s, t$ such that
$$sa + bt = r,$$
where $r$ is the resultant of $a$ and $b$.

\begin{lstlisting}
bezout{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return a tuple $(r, s, t)$ such that $r$ is the resultant of $a$ and $b$
and with polynomials $s, t$ such that $r = as + bt$.}

\textbf{Examples.}

Here are some examples of computing the Bezout identity.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 3x*y^2 + (x + 1)*y + 3
g = 6(x + 1)*y + (x^3 + 2x + 2)
r, s, t = gcdx(f, g)
\end{lstlisting}

\subsubsection{Special polynomials}

The following functions compute univariate special polynomials. It is expected
that the final argument in each of these function is the generator of the polynomial ring.

\begin{lstlisting}
chebyshev_t{T <: RingElem}(n::Int, x::Poly{T})
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $T_n(x)$, defined by 
$T_n(x) = \cos(n \cos^{-1}(x))$.}

\begin{lstlisting}
chebyshev_u{T <: RingElem}(n::Int, x::Poly{T})
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $U_n(x)$, defined by 
$(n+1) U_n(x) = T'_{n+1}(x)$.}

\textbf{Examples.}

Here are some examples of special polynomials.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = chebyshev_t(20, y)
g = chebyshev_u(15, y)
\end{lstlisting}

\subsection{Generic residue rings ($R/(f)$) : \code|Residue\{T\}|}

Nemo allows the construction of residue rings. 

There are two examples to keep in mind:

\begin{enumerate}
\item $\Z/n\Z$ for some positive integer $n$

\item $\Q[x]/(f)$ where $f$ is a polynomial in $\Q[x]$.
\end{enumerate}

Currently we only allow construction of residue rings of the form $R/(r)$ where
$R$ is a ring and $(r)$ is a principal ideal generated by an element $r \in R$. 

In the first example above the principal ideal is $(n)$ and in the second the principal
ideal is $(f)$.

We don't require the ideal $(r)$ to be maximal or prime (corresponding in the
commutative case to residue rings that are fields and integral domains 
respectively). 

Instead, we allow $r$ to be any nonzero element of $R$, but raise an exception
every time a computation in $R/(r)$ requires computing an impossible inverse.

The parent object for a residue ring in Nemo has type \code{ResidueRing} belonging
to the type class \code{Ring} and residues have type \code{Residue} belonging to
the type class \code{ResidueElem} which in turn belongs to \code{RingElem}. 

There is no need to deal directly with these types, as we provide a function
\code{ResidueRing} for constructing residue ring parent objects and various
constructors for creating residue objects.

Both the \code{ResidueRing} and \code{Residue} types are parameterised by the
type of objects in the base ring over which the residue ring is constructed.

Each \code{Residue} object contains a pointer to its parent object, which in
turn contains the modulus for the residue.

\subsubsection{Constructors}

To make it easy to deal with the \code{ResidueRing} type in Nemo, we provide a
function for constructing the parent object of a residue ring

\begin{lstlisting}
ResidueRing{T <: RingElem}(S::Ring, el::T)
ResidueRing{T <: RingElem}(S::Ring, el::Integer)
\end{lstlisting}

\desc{This function takes a base ring \code{S} and an element \code{el} of that
ring. The function returns a parent object for the residue ring \code{S/(el)}.}

In the constructors below we assume \code{R} has been created using the 
\code{ResidueRing} constructor, e.g:

\begin{lstlisting}
R = ResidueRing(ZZ, 17)
\end{lstlisting}

We now discuss the various constructors available to create \code{Residue}
objects that belong to the given ring. In each case, \code{T} is the type of
elements of the base ring of the residue ring.

\begin{lstlisting}
R(a::T)
R(a::Integer)  
\end{lstlisting}

\desc{Create a residue congruent to $a$. The value $a$ is first reduced
modulo the modulus of the residue ring.}

\begin{lstlisting}
R(a::Residue{T})  
\end{lstlisting}

\desc{Return a reference to the residue $a$. No copy of the data is made.}

\begin{lstlisting}
Residue()
\end{lstlisting}

\desc{Create a new residue, which is congruent to $0$.}

\begin{lstlisting}
Residue(a::RingElem)
\end{lstlisting}

\desc{Try to coerce $a$ into the base ring of the residue ring and then
create a new residue congruent to it.}

\textbf{Examples.}

Here are some examples of constructing residue rings and elements in them.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = R(123)
g = R(f)
h = R(fmpz(12))
k = R()

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

m = T(x^4)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
modulus{T <: RingElem}(R::ResidueRing{T})
modulus{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return the modulus of the given residue ring or of the parent of the given
residue element respectively.}

\begin{lstlisting}
data{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return the value stored in the given residue element as an element of the
base ring.}

\begin{lstlisting}
zero{T <: RingElem}(R::ResidueRing{T})
\end{lstlisting}

\desc{Return the additive identity of the given residue ring.}

\begin{lstlisting}
one{T <: RingElem}(::ResidueRing{T})
\end{lstlisting}

\desc{Return the multiplicative identity of the given residue ring.}

\begin{lstlisting}
iszero{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return \code{true} if the residue $a$ is the additive identity in the
residue ring, otherwise return \code{false}.}

\begin{lstlisting}
isone{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return \code{true} if the residue $a$ is the multiplicative identity in
the residue ring, otherwise return \code{false}.}

\begin{lstlisting}
isunit{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return \code{true} if the residue $a$ is invertible in the residue ring,
otherwise return \code{false}.}

\begin{lstlisting}
canonical_unit{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Used for canonicalising fractions. The function simply returns $a$. No
check is performed to check that $a$ is actually invertible.}

\begin{lstlisting}
deepcopy{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Create a new residue element which is arithmetically equal to the given
residue element.}

\textbf{Examples.}

Here are some examples of basic manipulation of residue rings.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = modulus(R)
g = zero(R)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

h = one(T)

k = isunit(h)

m = canonical_unit(R(11))
n = canonical_unit(T(x + 1))

p = isone(h)
q = iszero(g)
\end{lstlisting}

\subsubsection{Unary operations}

\begin{lstlisting}
-{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = -R(12345)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

h = -T(x^5 + 1)
\end{lstlisting}

\subsubsection{Binary operators}

The following binary operators for residue rings are provided.

\begin{lstlisting}
+{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return $ab$.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 12)

f = R(4)
g = R(6)

h = f + g
j = f - g
k = f*g

Q = ResidueRing(ZZ, 7)
S, x = PolynomialRing(Q, "x")
T = ResidueRing(S, x^3 + 3x + 1)

n = T(x^5 + 1)
p = T(x^2 + 2x + 1)

q = n + p
r = n - p
s = n*p
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return $a$ divided by $b$. If an impossible inverse is encounted
an exception is thrown.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
Q = ResidueRing(ZZ, 7)

a = Q(3)
b = Q(4)

m = divexact(a*b, a)

S, x = PolynomialRing(Q, "x")
T = ResidueRing(S, x^3 + 3x + 1)

n = T(x^5 + 1)
p = T(x^2 + 2x + 1)

t = divexact(n*p, p)
\end{lstlisting}

\begin{lstlisting}
gcd{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\subsubsection{GCD}

\desc{Return the greatest common divisor of $a$ and $b$. 

Recall that $a$ and $b$ are represented by values $a'$ and $b'$ in the base
ring. We define the greatest common divisor of $a$ and $b$ to be the residue
class of gcd$($gcd$(a', b'), m)$ when that is defined, where $m$ is the
modulus of the residue ring.

This definition does not depend on the choice of representatives of
$a$ and $b$.}

\textbf{Examples.}

Here are some examples of GCD.

\begin{lstlisting}
R = ResidueRing(ZZ, 12)

f = R(4)
g = R(6)

l = gcd(f, g)

Q = ResidueRing(ZZ, 7)
S, x = PolynomialRing(Q, "x")
T = ResidueRing(S, x^3 + 3x + 1)

n = T(x^5 + 1)
p = T(x^2 + 2x + 1)

u = gcd(n, p)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

In a residue ring $R$ over a ring $T$, with modulus $m$, it is convenient
to think of $n \in \Z$ as corresponding to $1$ added to itself $n$ times
in $T$ then reduced modulo $m$.

This allows us to efficiently define the following ad hoc operators, which
effectively make the integers $n \in \Z$ a convenient notation for certain
elements of the residue ring $R$.

\begin{lstlisting}
+{T <: RingElem}(a::Residue{T}, b::Integer)
+{T <: RingElem}(a::Integer, b::Residue{T})
\end{lstlisting}

\desc{Return $a + b$ with the integer operand thought of as an element of 
the given residue ring.}

\begin{lstlisting}
-{T <: RingElem}(a::Residue{T}, b::Integer)
-{T <: RingElem}(a::Integer, b::Residue{T})
\end{lstlisting}

\desc{Return $a - b$ with the integer operand thought of as an element of 
the given residue ring.}

\begin{lstlisting}
*{T <: RingElem}(a::Residue{T}, b::Integer)
\end{lstlisting}

\desc{Return $ab$, i.e. the element $a$ added to itself $b$ times.}

\begin{lstlisting}
*{T <: RingElem}(a::Integer, b::Residue{T})
\end{lstlisting}

\desc{Return $ab$, i.e. the element $b$ added to itself $a$ times.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

b = a + 3
c = 3 - a
d = 5a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = f + 4
h = 4 - f
k = f*5
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={T, S}(x::Residue{T}, y::Residue{T})
\end{lstlisting}

\desc{Return \code{true} if $x = y$ arithmetically in the given residue ring, 
otherwise return false.}

Julia automatically defines a \code{!=} operator.

\begin{lstlisting}
isequal(x::Residue{T}, y::Residue{T})
\end{lstlisting}

\desc{Returns \code{true} if the residues (as elements of the base ring) compare
equal recursively according to \code{isequal}, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of comparisons.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)
b = a
c = R(2)

b == a
c != a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = 8f
h = f + g

f == g
h != g
isequal(f, g)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

Thinking of integers as corresponding to elements of a residue ring, we
can define the following ad hoc comparison operators.

\begin{lstlisting}
=={T, S}(x::Residue{T}, y::Integer)
\end{lstlisting}

\desc{Given $x \in R$ for some residue ring $R$, return \code{true} 
if $x = y.1$ in $R$, otherwise return \code{false}.}

\begin{lstlisting}
=={T, S}(x::Integer, y::Residue{T})
\end{lstlisting}

\desc{Given $y \in R$ for some residue ring $R$, return \code{true} 
if $x.1 = y$ in $R$, otherwise return \code{false}.}

Julia automatically provides corresponding \code{!=} operators.

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

a == 3
4 != a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

f != 5
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::Residue{T}, b::Int)
\end{lstlisting}

\desc{Return $a^b$.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

b = a^5

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

g = f^100
\end{lstlisting}

\subsubsection{Inversion}

So long as we don't encounter an impossible inverse, we can
invert an element in a residue ring $R = T/(m)$, if $T$ is a
Euclidean ring, i.e. if we have a \code{gcd} function in $T$.

\begin{lstlisting}
inv{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$ in the given residue
ring, i.e. return an element $b$ such that $ab = 1$ in the residue ring,
if such exists. If an impossible inverse is encountered during the
computation, we throw an exception.}

\textbf{Examples.}

Here are some examples of computing inverses.

\begin{lstlisting}
R = ResidueRing(ZZ, 49)

a = R(5)

b = inv(a)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

g = inv(f)
\end{lstlisting}

\subsubsection{Exact division}

So long as we don't encounter an impossible inverse, we can
divide elements in a residue ring $R = T/(m)$, if $T$ is a
Euclidean ring, i.e. if we have a \code{gcd} function in $T$.

\begin{lstlisting}
divexact{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return the quotient of $a$ by $b$ in the given residue
ring, i.e. return an element $c$ such that $ac = b$ in the residue ring,
if such exists. If an impossible inverse is encountered during the
computation, we throw an exception.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R = ResidueRing(ZZ, 49)

a = R(5)
b = R(3)

c = divexact(a, b)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = T(x^4 + x + 2)

h = divexact(f, g)
\end{lstlisting}

\subsection{Generic power series rings ($R[[x]]$): \code|PowerSeries\{T\}|}

In Nemo we provide univariate power series rings. The type of a parent object for
a power series ring is a \code{PowerSeriesRing} which belongs to the \code{Ring}
type class. Power series elements are of type \code{PowerSeries} which belongs to
the \code{SeriesElem} type class, which in turn belongs to \code{RingElem}.

There's no need to deal directly with these types, as we provide a function
\code{PowerSeriesRing} for constructing the ring parent objects and various
constructors to create power series element objects.

As for the \code{Poly} type, the \code{PowerSeries} and \code{PowerSeriesRing}
types take as parameters the type \code{T} of the elements in the base ring
over which the power series ring is constructed.

For example, if there wasn't a special Flint type for power series, the type of
a power series ring $\Z[[x]]$ over the Flint integers would be denoted
\code|PowerSeriesRing{fmpz}| and elements of the ring would have type
\code|PowerSeries{fmpz}|.

Power series differ from polynomials in Nemo primarily in that they have a
precision attached to them. Each power series object has its own precision,
stored in a field \code{prec} and each power series parent object has a
maximum precision, stored in \code{prec_max}.

The precision is always a non-negative integer.

By default, power series in Nemo use a \emph{capped relative} precision model.
This means that the precision of a power series in a given ring is capped at
the precision given by \code{prec_max}. Moreover, the precision of each 
individual power series is relative, meaning that if the leading term of
a nonzero power series element is $c_ax^a$ and the precision is $b$ then the
power series is of the form $c_ax^a + c_{a+1}x^{a+1} + \ldots + O(x^{a + b})$.

The zero power series is simply taken to be $0 + O(x^b)$.

(Another commonly seen model of power series is the \emph{capped absolute}
model. In that case a precision $b$ would indicate that all power series are
of the form $c_0x^0 + c_1x + \ldots + O(x^b)$, where $c_0$ need not be
nonzero. Currently Nemo doesn't provide an implementation of the capped
absolute model.)

The capped relative model has the advantage that power series are stable
multiplicatively. In other words, for nonzero power series $f$ and $g$ we
have that \code{divexact(f*g), g) == f}.

However, capped relative power series are not additively stable, i.e. we
do not always have $(f + g) - g = f$.

In the capped relative model we say that two power series are equal if they
agree up to the \emph{absolute} precision of the two power series. Thus, for
example, $x^5 + O(x^10) == 0 + O(x^5)$, since the minimum absolute precision
is $5$.

During computations, it is possible for power series to ``lose'' precision
due to cancellation. For example if $f = x^3 + x^5 + O(x^8)$ and
$g = x^3 + x^6 + O(x^8)$ then $f - g = x^5 - x^6 + O(x^8)$ which now has
relative precision $3$ instead of relative precision $5$.

Amongst other things, this means that equality is not transitive. For example
$x^6 + O(x^11) == 0 + O(x^5)$ and $x^7 + O(x^12) == 0 + O(x^5)$ but
$x^6 + O(x^11) \neq x^7 + O(x^12)$.

Sometimes it is necessary to compare power series not just for arithmetic
equality, as above, but to see if they have precisely the same precision and
terms. For this purpose we introduce the \code{isequal} function.

For example, if $f = x^2 + O(x^7)$ and $g = x^2 + O(x^8)$ and $h = 0 + O(x^2)$
then $f == g$, $f == h$ and $g == h$, but \code{isequal(f, g)},
\code{isequal(f, h)} and \code{isequal(g, h)} would all return \code{false}.
However, if $k = x^2 + O(x^7)$ then \code{isequal(f, k)} would return
\code{true}.

There are further difficulties if we construct polynomial over power series.
For example, consider the polynomial in $y$ over the power series ring in $x$
over the rationals. Normalisation of such polynomials is problematic. For
instance, what is the leading coefficient of $(0 + O(x^10))y + (1 + O(x^10))$?

If one takes it to be $(0 + O(x^10))$ then some functions may not terminate
due to the fact that algorithms may require the degree of polynomials to
decrease with each iteration. Instead, the degree may remain constant and
simply accumulate leading terms which are arithmetically zero but not
identically zero.

On the other hand, when constructing power series over other power series, if
we simply throw away terms which are arithmetically equal to zero, our
computations may have different output depending on the order in which
power series are added!

One should be aware of these difficulties when working with power series.
Power series, as represented on a computer, simply don't satisfy the axioms
of a ring. They must be used with care in order to approximate operations in
a mathematical power series ring.

Simply increasing the precision will not necessarily give a ``more correct''
answer and some computations may not even terminate due to the presence of
arithmetic zeroes!

Note that power series in Nemo are currently \emph{stored} in absolute 
rather than relative format. Thus $x^10 + O(x^30)$ has a length $11$
polynomial underlying it, rather than a length $1$ polynomial. This may
change in a later version of Nemo.

\subsubsection{Constructors}

We define the following function for constructing the parent object of a
power series ring.

\begin{lstlisting}
PowerSeriesRing(R::Ring, p::Int, s::String)
\end{lstlisting}

\desc{Returns a tuple \code{(S, x + O(x^p))} consisting of the parent \code{S} 
corresponding to the power series ring over the ring \code{R} and the generator
\code{x + O(x^p)} of that power series ring, where $p$ is the maximum precision
of elements of the power series ring.

The generator \code{x + O(x^p)} will be printed as per the supplied string
\code{s}, which specifies the variable for the power series. This need not be the
same as the variable name used to store the generator \code{x}, but it is usually
convenient to make it to be so.}

We also provide various constructors for creating elements of a power series
ring. Below we assume that $S$ is a power series ring parent object, created
for example by the following code:

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")
\end{lstlisting}

We will also let $p$ stand for the maximum precision, e.g. $p = 30$ in the case of
$S$ as we just defined it, and $x$ to be the variable of the power series. We let
$T$ stand for the type of the coefficients of the power series.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Create the power series $0 + O(x^p)$.}

\begin{lstlisting}
S(a::Integer)
S(a::T)
\end{lstlisting}

\desc{Create the power series $a + O(x^p)$.}

\begin{lstlisting}
S(a::PowerSeries{T})
\end{lstlisting}

\desc{Return a reference to the power series \code{a}. No copy of the data is
made by this function.}

\begin{lstlisting}
S(a::Array{T, 1}, n::Int p::Int)
\end{lstlisting}

\desc{Create a power series with precision \code{p} and with coefficients given
by the array \code{a}. The constant coefficient of the power series will be the
first element in the array. The length \code{n} must be a nonnegative integer
and may not exceed the number of elements in the array, though it may be less
(this is useful so that one does not have to create a new array if the array
has trailing zeros). All but the first \code{n} terms of the array are ignored.}

\begin{lstlisting}
S(a::RingElem)
\end{lstlisting}

\desc{Try to coerce $a$ into the base ring of the power series ring and then
construct the power series $a + O(x^p)$.}

\begin{lstlisting}
O(a::PowerSeries{T})
\end{lstlisting}

\desc{The power series $a$ should be of the form \code{x^n} for some nonnegative
\code{n}. The function then returns $0 + O(x^n)$ with the same parent as the
supplied power series.

If the power series $0$ is passed to this function we throw a \code{DomainError()}. 

Note that whilst we do not disallow it, we do not give any special meaning to
expressions like $O(x - 1)$. Only the highest degree of the nonzero terms is
observed.}

\textbf{Examples.}

Here are some examples of power series constructors.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = x^3 + 2x + 1
b = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)

c = S(a)
d = S([t + 1, t, R(1)], 3, 5)

g = S(1)
h = S(fmpz(2))
k = S()
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
length{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return the length of the polynomial underlying the power series $a$, i.e.
its degree plus one. Recall that power series in Nemo are stored in absolute
format, not relative format, so the length of the underlying polynomial may be
much bigger than the precision due to leading zeros.}

\begin{lstlisting}
normalise{T <: RingElem}(a::PowerSeries{T}, len::Int)
\end{lstlisting}

\desc{Return the normalised length of the polynomial representing the power
series \code{a}, assuming that its unnormalised length is \code{len}. The
polynomial representing \code{a} is normalised if it has either length $0$
or its leading coefficient is nonzero. This function is mainly used internally
because all user functions in Nemo normalise the internal polynomial
representation of power series.}

\begin{lstlisting}
coeff{T <: RingElem}(a::PowerSeries{T}, n::Int)
\end{lstlisting}

\desc{Return the coefficient of the power series \code{a} with degree 
\code{n}. If $n < 0$ we throw a \code{DomainError()} and if $n$ is greater
than or equal to the power series precision we return $0$.}

\begin{lstlisting}
zero{T <: RingElem}(R::PowerSeriesRing{T})
\end{lstlisting}

\desc{Return $0 + O(x^p)$ where $p$ is the maximum precision for the
given power series ring and where $x$ is its variable.}

\begin{lstlisting}
one{T <: RingElem}(::Type{PowerSeries{T}})
\end{lstlisting}

\desc{Return $1 + O(x^p)$ where $p$ is the maximum precision for the
given power series ring and where $x$ is its variable.}

\begin{lstlisting}
gen{T <: RingElem}(::Type{PowerSeries{T}})
\end{lstlisting}

\desc{Return $x + O(x^{p+1})$ where $p$ is the maximum precision for the
given power series ring and where $x$ is its variable.}

\begin{lstlisting}
iszero{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is arithmetically equal to $0$ in the
power series ring up to the precision of $a$.}

\begin{lstlisting}
isone{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is arithmetically equal to $1$ in the
power series ring up to the precision of $a$.}

\begin{lstlisting}
isgen{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is arithmetically equal to $x$ in the
power series ring up to the precision of $a$.}

\begin{lstlisting}
isunit{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is an invertible element of the power series
ring, i.e. if the lead term is degree zero with invertible coefficient.
Otherwise, return \code{false}.}

\begin{lstlisting}
valuation{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return the valuation of the power series \code{a} with respect to the
generator of the power series ring. If the power series is zero to finite
precision $n$, the valuation is defined to be $n$.}

\begin{lstlisting}
precision{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return the (absolute) precision of the power series \code{a}.}

\begin{lstlisting}
max_precision{T <: RingElem}(R::PowerSeriesRing{T})
\end{lstlisting}

\desc{Return the maximum precision for the given power series ring. Recall
that this is a relative precision.}

\begin{lstlisting}
deepcopy{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Create a new power series object which is precisely equal to the
supplied power series, i.e. with the same coefficients and precision.}

\textbf{Examples.}

Here are some examples of basic manipulations of power series.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = O(x^4)
b = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)

c = gen(R)
d = zero(R)
f = one(R)

g = iszero(d)
h = isone(f)
k = isgen(c)
m = isunit(-1 + x + 2x^2)
n = valuation(a)
p = valuation(b)
q = deepcopy(a)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = 1 + 2x + x^2 + O(x^3)

c = -a
d = -b
\end{lstlisting}

\subsubsection{Binary operators}

\begin{lstlisting}
+{T <: RingElem}(a::PowerSeries{T}, b::PowerSeries{T})
\end{lstlisting}

\desc{Return $a + b$. If the two power series have differing absolute
precisions, the result will be a power series with the lower precision.}

\begin{lstlisting}
-{T <: RingElem}(a::PowerSeries{T}, b::PowerSeries{T})
\end{lstlisting}

\desc{Return $a - b$. If the two power series have differing absolute
precisions, the result will be a power series with the lower precision.}

\begin{lstlisting}
*{T <: RingElem}(a::PowerSeries{T}, b::PowerSeries{T})
\end{lstlisting}

\desc{Return $ab$. The return precision is equal to the least out of the
sum of the precision of \code{a} and the valuation of \code{b} and
the sum of the valuation of \code{a} and the precision of \code{b}.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 3x^2 + O(x^5)
d = x^2 + 3x^3 - x^4

f = a + b
g = a - c
h = b*c
j = a*c
m = a*d
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*{T <: RingElem}(a::Int, b::PowerSeries{T})
*{T <: RingElem}(a::fmpz, b::PowerSeries{T})
\end{lstlisting}

\desc{Return $ab$. The resulting power series will have the same precision as
$b$.}

\begin{lstlisting}
*{T <: RingElem}(a::PowerSeries{T}, b::Int)
*{T <: RingElem}(a::PowerSeries{T}, b::fmpz)
\end{lstlisting}

\desc{Return $ab$. The resulting power series will have the same precision as
$a$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 3x^2 + O(x^5)
d = x^2 + 3x^3 - x^4

f = 2a
g = fmpz(3)*b
h = c*2
j = d*fmpz(3)
\end{lstlisting}

\subsubsection{Comparison}

Note that we take the convention that $1 + x + O(x^4) == 1 + x + O(x^8)$. 

\begin{lstlisting}
=={T <: RingElem}(x::PowerSeries{T}, y::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if the two power series are the same up to the lesser
of the precisions of the two series, otherwise return \code{false}.}

Julia automatically defines a corresponding \code{!=} operator.

\begin{lstlisting}
isequal(x::PowerSeries{T}, y::PowerSeries{T})
\end{lstlisting}

\desc{Returns \code{true} if the $x == y$, the precisions of $x$ and $y$ are
the same and if each coefficient of $x$ recursively compares equal to the
corresponding coefficient of $y$ according to \code{isequal}, otherwise return
\code{false}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^3)
c = 1 + x + 3x^2 + O(x^5)
d = 3x^3 - x^4

a == 2x + x^3
b == d
c != d
isequal(b, d) == false
\end{lstlisting}

\subsubsection{Ad hoc comparison}

Note that we take the convention that $0 == 0 + O(x^4)$.

\begin{lstlisting}
=={T <: RingElem}(x::PowerSeries{T}, y::Int)
=={T <: RingElem}(x::PowerSeries{T}, y::fmpz)
\end{lstlisting}

\desc{Return \code{true} if the power series \code{x} is equal to \code{y} up
to the precision it has. Note that this is always true if \code{x} has
precision $0$.}

\begin{lstlisting}
=={T <: RingElem}(x::Int, y::PowerSeries{T})
=={T <: RingElem}(x::fmpz, y::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if the power series \code{y} is equal to \code{x} up
to the precision it has. Note that this is always true if \code{y} has
precision $0$.}

Julia automatically defines a corresponding \code{!=} operator corresponding to
the above.

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^0)
c = 1 + O(x^5)
d = S(3)

d == 3
c == fmpz(1)
fmpz(0) != a
2 == b
fmpz(1) == c
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::PowerSeries{T}, b::Int)
\end{lstlisting}

\desc{Return $a^b$. The result will have precision equal to $b - 1$ times the
valuation of $a$ plus the precision of $a$. This is the same as if $a$ were
multiplied by itself $b$ times.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = a^12
g = b^12
h = c^12
k = d^12
\end{lstlisting}

\subsubsection{Shifting}

\begin{lstlisting}
shift_left{T <: RingElem}(a::PowerSeries{T}, n::Int)
\end{lstlisting}

\desc{Return \code{a*x^n}, where \code{x} is the generator of the power series
ring and \code{n} is a nonnegative integer. If \code{n} is negative we raise
a \code{DomainError()}.}

\begin{lstlisting}
shift_right{T <: RingElem}(a::PowerSeries{T}, n::Int)
\end{lstlisting}

\desc{Return \code{a/x^n}, discarding the remainder, where \code{x} is the
generator of the power series ring and \code{n} is a nonnegative integer. If 
\code{n} is negative we raise a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of shifting.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = shift_left(a, 2)
g = shift_left(b, 2)
h = shift_right(c, 1)
k = shift_right(d, 3)
\end{lstlisting}

\subsubsection{Truncation}

\begin{lstlisting}
truncate{T <: RingElem}(a::PowerSeries{T}, prec::Int)
\end{lstlisting}

\desc{Return the power series \code{a} truncated to the given (absolute)
precision. If \code{a} already has precision less than or equal to \code{prec}
this results in no change. If \code{prec} is negative we throw a
\code{DomainError()}.}

\textbf{Examples.}

Here are some examples of truncation.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = truncate(a, 3)
g = truncate(b, 2)
h = truncate(c, 7)
k = truncate(d, 5)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{T <: RingElem}(x::PowerSeries{T}, y::PowerSeries{T})
\end{lstlisting}

\desc{Return the quotient of $x$ by $y$. This requires \code{x} to have
valuation at least that of \code{y}. It also requires the first nonzero
coefficient of \code{y} to be a unit in the ring \code{T}. If \code{y}
is zero, a \code{DivideError()} is thrown. 

The precision of the result is equal to the minimum of $p_x - v_y$
and $p_y - 2v_y + v_x$ where $p_x$, $p_y$ are the precisions of \code{x} and
\code{y} respectively and $v_x$, $v_y$ are the corresponding valuations.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = x + x^3 + O(x^6)

f = divexact(a, d)
g = divexact(d, a)
h = divexact(b, c)
k = divexact(d, c)
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact{T <: RingElem}(x::PowerSeries{T}, y::Int)
divexact{T <: RingElem}(x::PowerSeries{T}, y::fmpz)
divexact{T <: RingElem}(x::PowerSeries{T}, y::T)
divexact{T <: RingElem}(x::PowerSeries{T}, y::Integer)
\end{lstlisting}

\desc{Return the quotient of $x$ by $y$. If \code{y} is zero, a
\code{DivideError()} is thrown. 

The precision of the result is equal to that of $x$.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = x + x^3 + O(x^6)

f = divexact(a, 7)
g = divexact(b, fmpz(11))
h = divexact(c, fmpz(2))
k = divexact(d, 9)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return the power series inverse of $a$. A \code{DivideError()} is thrown 
if \code{a} is zero. An exception is thrown if \code{a} isn't invertible.

The precision of the result is equal to the precision of \code{a}.}

\textbf{Examples.}

Here are some examples of inversion.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 1 + x + 2x^2 + O(x^5)
b = S(-1)

c = inv(a)
d = inv(b)
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
exp{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Compute the power series exponential of the given power series \code{a}
to the same precision as \code{a}. The valuation of \code{a} must be nonzero.}

\textbf{Examples.}

Here are some examples of special functions.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = exp(x + O(x^40))
b = divexact(x, exp(x + O(x^40)) - 1)
\end{lstlisting}

\section{Generic fields}

Nemo provides various constructions of fields. 

Nemo defines the abstract type \code{Field} like so:

\begin{lstlisting}
abstract Field <: Ring
\end{lstlisting}

This means fields can be used anywhere that a more general ring can be used
in Nemo.

Division in a field can be performed with \code{divexact}. Of course all
divisions in a field are exact, except division by zero which will raise
a \code{DivideError()}.

The \code{//} operator doubles as a division operator when passed operands
in a field. It is an alias for \code{divexact}.

\subsection{Fraction fields Frac$(R)$: \code|Fraction\{T\}|}

We allow the construction of a fraction field over any ring in Nemo. Not all
such constructions make sense. Typically it only makes sense to construct the
fraction field of an integral domain. However, so long as zero divisors are
avoided there is nothing stopping one constructing the fraction field of a
more general Euclidean ring in Nemo.

Specifically, a ring must provide a \code{gcd} function before we can take its
fraction field. This is required for canonicalisation.

The type of an element of a fraction field in Nemo is \code{Fraction} which
belongs to the type class \code{FractionElem} which in turn belongs to
\code{FieldElem}. The type of a fraction field parent object is
\code{FractionField} which belongs to \code{Field}.

The user need never deal directly with these types, as we provide convenient
functions for constructing objects of those types.

The types of \code{FractionField} parent objects and \code{Fraction} elements
are parameterised by the type \code{T} of elements of the base ring of the
fraction field.

The generic \code{Fraction} objects contain a numerator and denominator, both
of type \code{T}, and a pointer to the parent fraction field object.

The fraction field parent objects can be used to construct fractions in the
given fraction field.

The fractions in Nemo are canonicalised, which means that we divide both
numerator and denominator by their greatest common divisor. We also divide
by \code{canonical_unit(d)} where \code{d} is the denominator when needed,
e.g. when printing fractions or taking their numerator or denominator, etc.
We also use this to easily check equality of fractions.

The \code{canonical_unit} function must have the properties

\begin{lstlisting}
canonical_unit(u) == u
canonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)
\end{lstlisting}

for all nonzero values $a$ and $b$ in the base ring and $u$ any invertible element
in the base ring. Moreover, \code{canonical_unit} must always return an invertible
element in the base ring for nonzero elements of the ring.

We overload the \code{//} operator in Nemo for rings whose fraction field can
be taken (e.g. \code{fmpz} and \code|Poly{T}|), so that elements of the
fraction field of a ring can be constructed directly, without first
constructing the type.

For example if we have

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

s = (x + 1)//(x^2 + 1)
\end{lstlisting}

then the value $s$ belongs to the fraction field of $R$ automatically, even
though this field has not been constructed yet.

In Nemo, we consider the fraction field of a field to be itself.

\subsubsection{Constructors}

We provide a convenient function for constructing a fraction field of a ring in
Nemo.

\begin{lstlisting}
FractionField(R::Ring)
\end{lstlisting}

\desc{Construct the fraction field of the given ring.}

There are also numerous constructors for generating elements in the fraction
field. In the constructor below, we assume $S$ is the fraction field of a ring,
e.g. as constructed by the following:

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S = FractionField(R)
\end{lstlisting}

We assume $T$ represents the type of elements of the base ring.

\begin{lstlisting}
S(a::T)
\end{lstlisting}

\desc{Construct the canonicalised fraction \code{a//1} in the fraction field.}

\begin{lstlisting}
S(a::Integer)
S(a::T)
\end{lstlisting}

\desc{Return the value $a//1$ in the fraction field.}

\begin{lstlisting}
S(a::Integer, b::Integer)
S(a::T, b::T)
S(a::T, b::Integer)
S(a::Integer, b::T)
\end{lstlisting}

\desc{Construct the canonicalised fraction \code{a//b} in the fraction field. If
$b = 0$ we throw a \code{DivideError()} and an exception is raised in general
if $b$ is not invertible.}

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Return the value $0/1$ in the fraction field.}

\begin{lstlisting}
S(a::Fraction{T})
\end{lstlisting}

\desc{Return a reference to the value $a$. No copy of the data is made.}

\begin{lstlisting}
S(b::RingElem)
\end{lstlisting}

\desc{Coerce $b$ into the base ring of the fraction field and construct the
fraction $b//1$.}

We also provide a simpler way of constructing elements of a fraction field
without needing to first construct the type of the fraction field. 

\begin{lstlisting}
//(x::T, y::T)
//(x::T, y::Integer)
//(x::Integer, y::T)
\end{lstlisting}

\desc{Return the canonicalised value $x//y$ in the fraction field. In the cases
where one argument is an integer, it is first coerced into the base ring. If
$y = 0$ we throw a \code{DivideError()} and an exception is raised in general
if $y$ is not invertible.}

\textbf{Examples.}

Here are some examples of constructors for fraction fields.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")
T = FractionField(S)

b = T(3)
c = T(fmpz(7))
d = T(x + 2)
f = T(d)
g = T()
h = T(x + 1, x + 2)

k = (x + 3)//(x^2 + 2)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
num{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return the numerator of the fraction $a$.}

\begin{lstlisting}
den{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return the denominator of the fraction $a$.}

\begin{lstlisting}
zero{T <: RingElem}(R::FractionField{T}})
\end{lstlisting}

\desc{Return the additive identity of the fraction field of the ring $T$.}

\begin{lstlisting}
one{T <: RingElem}(R::Type{FractionField{T}})
\end{lstlisting}

\desc{Return the multiplicative identity of the fraction field of the ring 
$T$.}

\begin{lstlisting}
iszero{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $a$ is the additive identity in the
fraction field, otherwise return \code{false}.}

\begin{lstlisting}
isone{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $a$ is multiplicative identity in the
fraction field, otherwise return \code{false}.}

\begin{lstlisting}
isunit{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $a$ is invertible, i.e. is not zero,
otherwise return \code{false}.}

\begin{lstlisting}
canonical_unit{T}(a::Fraction{T})
\end{lstlisting}

\desc{Used for canonicalising fractions. This function simply returns $a$.}

\begin{lstlisting}
deepcopy{T}(a::Fraction{T})
\end{lstlisting}

\desc{Creates a new fraction object arithmetically equal to $a$.}

\textbf{Examples.}

Here are some examples of basic manipulations for fraction fields.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = den((x + 1)//(-x^2 + 1))

c = zero(S)
d = one(S)
f = canonical_unit((x + 1)//(-x^2 + 1))
g = isunit((x + 1)//(-x^2 + 1))

h = iszero(c)
d = isone(d)
f = deepcopy(d)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here is an example of a unary operator.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -((x + 1)//(-x^2 + 1))
\end{lstlisting}

\subsubsection{Binary operators and functions}

The following binary operators are available for elements of fraction fields.
All of the functions canonicalise their outputs.

\begin{lstlisting}
+{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a*b$.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -(x + 3)//(x + 1) + (2x + 3)//(x^2 + 4)
b = (x + 1)//(-x^2 + 1) - x//(2x + 1)
c = ((x^2 + 3x)//(5x))*((x + 1)//(2x^2 + 2))
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following binary operators are more efficient than simply coercing both
arguments into the fraction field. All functions canonicalise their outputs.

\begin{lstlisting}
+{T <: RingElem}(a::Fraction{T}, b::Integer)
+{T <: RingElem}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a + b/1$.}

\begin{lstlisting}
+{T <: RingElem}(a::Integer, b::Fraction{T})
+{T <: RingElem}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 + b$.}

\begin{lstlisting}
-{T <: RingElem}(a::Fraction{T}, b::Integer)
-{T <: RingElem}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a - b/1$.}

\begin{lstlisting}
-{T <: RingElem}(a::Integer, b::Fraction{T})
-{T <: RingElem}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 - b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Fraction{T}, b::Integer)
*{T <: RingElem}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a * b/1$.}

\begin{lstlisting}
*{T <: RingElem}(a::Integer, b::Fraction{T})
*{T <: RingElem}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 * b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x + 1)//(-x^2 + 1)

c = a + 2
d = 3 - a
e = b*(x + 1)
\end{lstlisting}

\subsubsection{Comparison operators}

\begin{lstlisting}
=={T}(x::Fraction{T}, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $x$ equals the fraction $y$, else
return \code{false}.}

\begin{lstlisting}
isequal{T}(x::Fraction{T}, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the numerators of \code{x} times the denominator
of \code{y} compares equal recursively according to \code{isequal} with the
denominator of \code{x} times the numerator of \code{y}, else return
\code{false}.}

\textbf{Examples.}

Here are some examples of comparisons.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -(ZZ(4)/ZZ(6))
b = -((x + 1)/(-x^2 + 1))

a == -ZZ(2)/ZZ(3)
b == 1/(x - 1)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following comparison operators are faster than first coercing both
operands into the fraction field.

\begin{lstlisting}
=={T}(x::Fraction{T}, y::T)
\end{lstlisting}

\desc{Return \code{true} if the fraction $x$ equals the fraction $y/1$, else
return \code{false}.}

\begin{lstlisting}
=={T}(x::T, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $y$ equals the fraction $x/1$, else
return \code{false}.}

\begin{lstlisting}
=={T <: RingElem}(x::Fraction{T}, y::Integer)
\end{lstlisting}

\desc{Return \code{true} if the numerator of the fraction $x$ is equal to $y$
in the ring $T$ and the denominator is $1$, otherwise return \code{false}.}

\begin{lstlisting}
=={T <: RingElem}(x::Integer, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the numerator of the fraction $y$ is equal to $x$
in the ring $T$ and the denominator is $1$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = 1//(x - 1)

1//a == x - 1
1 == one(S)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::Fraction{T}, b::Int)
\end{lstlisting}

\desc{Return $a^b$. The exponent may be negative.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x + 1)//(-x^2 + 1)

c = a^(-12)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return $1/a$.}

\textbf{Examples.}

Here is an example of inversion.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x + 1)//(-x^2 + 1)

b = inv(a)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
//{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return the $a*inv(b)$.}

\begin{lstlisting}
divexact{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{An alias for \code{a//b}.}

\textbf{Examples.}

Here are an example of exact division.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x + 1)//(-x^2 + 1) 
b = -x//(2x + 1)

c = a//c
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Fraction{T}, b::Integer)
divexact{T <: RingElem}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a / (b/1)$.}

\begin{lstlisting}
divexact{T <: RingElem}(a::Integer, b::Fraction{T})
divexact{T <: RingElem}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $(a/1) / b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x^2)//(2x + 1)
b = (x + 1)//(-x^2 + 1)

f = a//5
g = (x + 1)//b
h = 3//b
\end{lstlisting}

\subsubsection{GCD}

\begin{lstlisting}
gcd{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $c/d$ where $c$ is the GCD of the numerators of $a$ and $b$ and
$d$ is the GCD of their denominators.}

\textbf{Examples.}

Here are some examples of binary operators and functions.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -x//(2x + 1)

f = gcd(a, (x + 1)/(x - 1))
\end{lstlisting}

\section{Flint rings}

Flint provides implementations of various explicit rings. These are used instead of generic
implementations where available.

We only describe the details that differ from the generic implementations above.

\subsection{Flint integers ($\Z$): \code{fmpz}}

Multi-precision integers can be created in Nemo using \code{ZZ}. For example, to create the integer
$123$ one can write:

\begin{lstlisting}
ZZ(123)
\end{lstlisting}

By default, \code{ZZ} creates objects of the Flint \code{fmpz} type. This is achieved internally by
setting \code{ZZ = FlintIntegerRing()}, which makes \code{ZZ} the unique object of type
\code{FlintIntegerRing}.

One can also create Flint integers using the \code{fmpz} constructor directly:

\begin{lstlisting}
fmpz(123)
\end{lstlisting}

In Nemo library code we use \code{fmpz} rather than \code{ZZ} since the latter is defined only for the
convenience of the user and its definition may be changed by the user. It is also slightly more
efficient to call \code{fmpz} directly, since \code{ZZ} is a global variable.

The type of an \code{fmpz} object is \code{fmpz}. Thus the following returns \code{Nemo.fmpz}:

\begin{lstlisting}
typeof(fmpz(123))
\end{lstlisting}

An object of this type corresponds directly to the Flint \code{fmpz} C type.

The parent of an \code{fmpz} object is the unique object of type \code{FlintIntegerRing}. Thus the
following returns ``Integer Ring'':

\begin{lstlisting}
parent(fmpz(123))
\end{lstlisting}

The \code{FlintIntegerRing} type belongs to the \code{Ring} type class and the \code{fmpz} type
belongs to the \code{RingElem} type class. Thus both of the following return true:

\begin{lstlisting}
fmpz <: RingElem
FlintIntegerRing <: Ring
\end{lstlisting}

\subsubsection{Constructors}

Nemo provides various constructors for the \code{fmpz} type. Space is automatically
recovered when the created object goes out of scope.

\begin{lstlisting}
fmpz()
\end{lstlisting}

\desc{Creates an initialised \code{fmpz}. Its value will be $0$.}

\begin{lstlisting}
fmpz(n::Int)
\end{lstlisting}

\desc{Create an \code{fmpz} with the given signed machine word value $n$.}

\begin{lstlisting}
fmpz(n::BigInt)
\end{lstlisting}

\desc{Create an \code{fmpz} with the given Julia \code{BigInt} value $n$.}

\begin{lstlisting}
fmpz(n::Integer)
\end{lstlisting}

\desc{Create an \code{fmpz} with the given value $n$, where $n$ has any type belonging to the Julia
\code{Integer} type class.}

\begin{lstlisting}
fmpz(n::Float16)
fmpz(n::Float32)
fmpz(n::Float64)
fmpz(n::BigFloat)
\end{lstlisting}

\desc{If $n$ is an exact integer, return the \code{fmpz} with the value $n$, otherwise raise an
\code{InexactError}.}

\begin{lstlisting}
fmpz(s::String)
\end{lstlisting}

\desc{Create an \code{fmpz} whose value is represented (in decimal) by the given string
$s$. The string should not contain any whitespace, and can optionally begin with
a $-$ sign.}

\begin{lstlisting}
fmpz(x::fmpz)
\end{lstlisting}

\desc{Returns a reference to $x$. No copy of the data is made.}

\begin{lstlisting}
deepcopy(x::fmpz)
\end{lstlisting}

\desc{Create a new \code{fmpz} whose value is arithmetically equal to that of $x$.}

\textbf{Examples.}

Here are some examples of the above constructors.

\begin{lstlisting}
a = fmpz(-123)
b = fmpz(12.0)
c = fmpz("-1234567876545678376545678900000000000000000000000000")
d = fmpz(BigFloat(10)^100)
e = fmpz(c)
f = deepcopy(c)
\end{lstlisting}

\subsubsection{Conversions}

It is possible to convert \code{fmpz} values to a variety of other types. This is
achieved by overloading Julia's \code{convert} function.

\begin{lstlisting}
Int(x::fmpz)
UInt(x::fmpz)
BigInt(x::fmpz)
Float64(x::fmpz)
Float32(x::fmpz)
Float16(x::fmpz)
BigFloat(x::fmpz)
\end{lstlisting}

\desc{Convert the \code{fmpz} $x$ to the given type.}

\textbf{Examples.}

Here are some examples of the above constructors.

\begin{lstlisting}
a = fmpz(-123)
b = fmpz(12)

c = Int(a)
d = UInt(b)
f = Float64(a)
g = BigFloat(a)
\end{lstlisting}

\subsubsection{Basic manipulation}

Various functions are provided to do basic manipulations of \code{fmpz}'s.

\begin{lstlisting}
one(::FlintIntegerRing)
\end{lstlisting}

\desc{Create the multiplicative identity element in the ring of integers.}

\begin{lstlisting}
zero(::FlintIntegerRing)
\end{lstlisting}

\desc{Create the additive identity element in the ring of integers.}

\begin{lstlisting}
isone(a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $a$ is the multiplicative identity $1$, otherwise
return \code{false}.}

\begin{lstlisting}
iszero(a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $a$ is the additive identity $0$, otherwise
return \code{false}.}

\begin{lstlisting}
isunit(a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $a = 1$ or $a = -1$, otherwise return \code{false}.}

\begin{lstlisting}
sign(a::fmpz)
\end{lstlisting}

\desc{Return either $-1$, $0$ or $1$ depending on whether the sign of $a$ is negative,
zero or positive, respectively. The returned value is of type \code{Int}.}

\begin{lstlisting}
fits(::Type{Int}, a::fmpz)
fits(::Type{Uint}, a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if the value $a$ will fit into a variable of the given
type. Otherwise return \code{false}.}

\begin{lstlisting}
size(a::fmpz)
\end{lstlisting}

\desc{Return the number of machine words that make up the bignum $a$. The
returned value has type \code{Int}.}

\begin{lstlisting}
canonical_unit(a::fmpz)
\end{lstlisting}

\desc{This is used for canonicalising fractions. The function simply returns $-1$
if $a < 0$, otherwise it returns $1$.}

\begin{lstlisting}
num(a::fmpz)
\end{lstlisting}

\desc{For convenience when working with rationals. Simply returns the value of \code{a}.}

\begin{lstlisting}
den(a::fmpz)
\end{lstlisting}

\desc{For convenience when working with rationals. Always returns \code{fmpz(1)}.}

\textbf{Examples.}

Here are some examples of the above basic manipulations.

\begin{lstlisting}
a = one(FlintIntegerRing()) # by default one(ZZ) is the same thing 
b = zero(FlintIntegerRing()) # by default zero(ZZ) is the same thing 

if sign(a) < 0
   println("Negative")
end

if fits(Int, a)
   println("Fits into an Int")
end

s = size(a)

t = canonical_unit(fmpz(-12))

u = isunit(fmpz(-1))
v = iszero(b)
w = isone(a)
\end{lstlisting}

\subsubsection{Binary operators}

The following standard binary operators are provided for \code{fmpz}. Note that \code{$} is Julia's
xor operator.

\begin{lstlisting}
+(a::fmpz, b::fmpz)
-(a::fmpz, b::fmpz)
*(a::fmpz, b::fmpz)
%(a::fmpz, b::fmpz)
&(a::fmpz, b::fmpz)
|(a::fmpz, b::fmpz)
$(a::fmpz, b::fmpz)
\end{lstlisting}

Note that \code{%} follows the C (and Julia) convention of rounding the quotient
towards zero. If $b = 0$ is passed to \code{%}, a \code{DivideError()} is thrown.

Julia automatically provides all of the combined assignment operators \code{+=, *=, &=}
etc.

Here are some examples of binary operators.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(26)

c = a + b
d = a - b
\end{lstlisting}

\subsubsection{Integer division}

Various kinds of integer division are provided.

\begin{lstlisting}
fdiv(a::fmpz, b::fmpz)
cdiv(a::fmpz, b::fmpz)
tdiv(a::fmpz, b::fmpz)
div(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Integer division with rounding towards $-\infty$, $+\infty$ and $0$ respectively.
Note \code{div} is a synonym for \code{tdiv}. If $b = 0$ is passed to any of these
functions, a \code{DivideError()} is thrown.}

Here are some examples of integer division.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(5)

c = cdiv(a, b)
d = fdiv(a, b)
\end{lstlisting}

\subsubsection{Remainder}

\begin{lstlisting}
mod(a::fmpz, b::fmpz)
mod(x::fmpz, c::Int)
rem(a::fmpz, b::fmpz)
rem(x::fmpz, c::Int)
\end{lstlisting}

\desc{Integer remainder after division with rounding towards $-\infty$ and $0$
respectively. Note that \code{\%} is a synonym for \code{rem}. If $b = 0$ is passed to 
any of these functions, a \code{DivideError()} is thrown.}

Here are some examples of the remainder functions.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(5)

c = mod(a, b)
d = rem(a, 3)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(a::fmpz, b::fmpz)
divexact(x::fmpz, c::Int)
\end{lstlisting}

\desc{Exact integer division. This is more efficient than the above division functions,
but will only return a meaningful result if the division is exact, i.e. if $b$ divides
$a$. If $b = 0$ is passed to this function, a \code{DivideError()} is thrown.}

Here is an example of exact division.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(6)

c = divexact(a, b)
c = divexact(a, 2)
\end{lstlisting}

\subsubsection{GCD and LCM}

\begin{lstlisting}
gcd(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Returns the greatest common divisor of $a$ and $b$. For convenience, 
gcd$(a, 0) = a$ and gcd$(0, b) = b$. The returned value is always nonnegative.}

\begin{lstlisting}
lcm(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Returns the lowest common multiple of $a$ and $b$, i.e. $ab/\gcd(a, b)$ if
$a, b > 0$. For convenience, lcm$(a, 0) = 0$ and lcm$(0, b) = 0$. The returned
value is always nonnegative.}

Here are some examples of GCD and LCM.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(15)

c = gcd(a, b)
d = lcm(a, b)
\end{lstlisting}

\subsubsection{Integer logarithms}

\begin{lstlisting}
flog(a::fmpz, b::fmpz)
flog(a::fmpz, b::Int)
\end{lstlisting}

\desc{Returns $\log_b(a)$ rounded towards $0$. Both $a$ and $b$ are required
to be positive, otherwise a \code{DomainError()} exception is thrown.}

\begin{lstlisting}
clog(a::fmpz, b::fmpz)
clog(a::fmpz, b::Int)
\end{lstlisting}

\desc{Returns $\log_b(a)$ rounded towards $\infty$. Both $a$ and $b$ are required
to be positive, otherwise a \code{DomainError()} exception is thrown.}

\textbf{Examples.}

Here are some examples of integer logarithms.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(3)

c = clog(a, b)
d = flog(a, 2)
\end{lstlisting}

\subsubsection{Ad hoc operators}

Since the Julia types \code{Int} and \code{Uint} cannot be made members of the
\code{Ring} class, we must define some ad hoc operators, so that values of type
\code{fmpz} can be more easily combined with \code{Int} and \code{Uint} values.

\begin{lstlisting}
+(x::fmpz, c::Integer)
+(x::fmpz, c::Int)
+(x::Integer, c::fmpz)
+(x::Int, c::fmpz)
-(x::fmpz, c::Integer)
-(x::fmpz, c::Int)
-(x::Integer c::fmpz)
-(x::Int, c::fmpz)
*(x::fmpz, c::Integer)
*(x::fmpz, c::Int)
*(x::Integer, c::fmpz)
*(x::Int, c::fmpz)
%(x::fmpz, c::Int)
\end{lstlisting}

Here are some examples of the ad hoc operators.

\begin{lstlisting}
a = fmpz(-12)

b = 3 + a
c = a + 3
d = a - 3
e = 5 - a
f = a % 7
\end{lstlisting}

\subsubsection{Ad hoc division}

We also define the following, which have the same semantics as the corresponding functions above.

\begin{lstlisting}
tdiv(x::fmpz, c::Int)
fdiv(x::fmpz, c::Int)
cdiv(x::fmpz, c::Int)
div(x::fmpz, c::Int)
\end{lstlisting}

Here are some examples of ad hoc division.

\begin{lstlisting}
a = fmpz(-12)

b = tdiv(a, 5)
c = cdiv(a, 3)
\end{lstlisting}

\subsubsection{Binary shifting}

We also define the following, which have the same semantics as the corresponding functions above.

There are also shift operators, which require the shift to be of type \code{Int}.

\begin{lstlisting}
<<(x::fmpz, c::Int)
\end{lstlisting}

\desc{Return $2^c x$.}

\begin{lstlisting}
fdivpow2(x::fmpz, c::Int)
cdivpow2(x::fmpz, c::Int)
tdivpow2(x::fmpz, c::Int)
>>(x::fmpz, c::Int)
\end{lstlisting}

\desc{Return $x/2^c$ with rounding towards $-\infty$, $+\infty$ and $0$ respectively. 
Note that \code{>>} is a synonym for \code{fdivpow2}.}

Here are some examples of binary shifting.

\begin{lstlisting}
a = fmpz(-12)

b = a << 3
c = a >> 1
d = fdivpow2(a, 2)
\end{lstlisting}

\subsubsection{Powering}

There is also the caret operator, which is used for powering in Julia (and Nemo), in
line with the mathematical convention.

\begin{lstlisting}
^(x::fmpz, a::Uint)
^(x::fmpz, a::Int)
\end{lstlisting}

\desc{Return $x^a$. Requires $a \geq 0$.}

\textbf{Examples.}

Here is an example of the caret operator.

\begin{lstlisting}
a = fmpz(-12)

b = a^10
\end{lstlisting}

\subsubsection{Comparison operators and functions}

The following standard comparison operators are provided for \code{fmpz}.

\begin{lstlisting}
==(a::fmpz, b::fmpz)
>(a::fmpz, b::fmpz)
<(a::fmpz, b::fmpz)
<=(a::fmpz, b::fmpz)
>=(a::fmpz, b::fmpz)
\end{lstlisting}

Julia automatically provides a \code{!=} operator.

Note that all these comparisons yield a result of type \code{Bool}.

There are also the following functions.

\begin{lstlisting}
isequal(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{For \code{fmpz} this is just an alias for the \code{==} operator.}

\begin{lstlisting}
cmp(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return $-1$ if $x < y$, $1$ if $x > y$ and $0$ if $x = y$.}

\begin{lstlisting}
cmpabs(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return $-1$ if $|x| < |y|$, $1$ if $|x| > |y|$ and $0$ if 
$|x| = |y|$, where $|x|$ is the absolute value of $x$.}

\textbf{Examples.}

Here are some examples of the comparison operators and functions.

\begin{lstlisting}
a = fmpz(-12)
b = fmpz(5)

if a < b
   println("a < b")
end

if cmpabs(a, b) == 0
   println("The absolute values of a and b are equal")
end
\end{lstlisting}

\subsubsection{Ad hoc comparison operators}

We overload the comparison operators to more easily deal with values of type \code{Int}.

\begin{lstlisting}
==(a::fmpz, b::Int)
==(a::Int, b::fmpz)
>(a::fmpz, b::Int)
>(a::Int, b::fmpz)
<(a::fmpz, b::Int)
<(a::Int, b::fmpz)
<=(a::fmpz, b::Int)
<=(a::Int, b::fmpz)
>=(a::fmpz, b::Int)
>=(a::Int, b::fmpz)
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the ad hoc comparison operators.

\begin{lstlisting}
a = fmpz(-12)

if a < 7
   println("a < 7")
end

if a == -12
   println("a == -12")
end
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-(x::fmpz)
\end{lstlisting}

\desc{Return $-x$.}

\begin{lstlisting}
~(x::fmpz)
\end{lstlisting}

\desc{Return the bignum corresponding to logical complement of the twos 
complement representation of x, namely $-x - 1$.}

Here are some examples of the unary operators.

\begin{lstlisting}
a = -fmpz(12)
b = ~fmpz(-5)
\end{lstlisting}

\subsubsection{Absolute value}

\begin{lstlisting}
abs(x::fmpz)
\end{lstlisting}

\desc{Return the absolute value of $x$, i.e. $x$ if $x >= 0$ and $-x$ otherwise.}

\textbf{Examples.}

Here is an example of the absolute value function.

\begin{lstlisting}
a = fmpz(-12)

b = abs(a)
\end{lstlisting}

\subsubsection{Division with remainder}

\begin{lstlisting}
fdivrem(a::fmpz, b::fmpz)
tdivrem(a::fmpz, b::fmpz)
divrem(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Return a tuple $(q, r)$ consisting of the quotient and remainder after 
division of $x$ by $y$, with rounding towards $-\infty$ and $0$ respectively. Note 
that \code{divrem} is a synonym for \code{tdivrem}. If $b = 0$ is passed to any
of these functions a \code{DivideError()} is thrown.}

\textbf{Examples.}

Here are some examples of the division with remainder functions.

\begin{lstlisting}
q, r = fdivrem(fmpz(12), fmpz(5))
q, r = tdivrem(fmpz(12), fmpz(5))
\end{lstlisting}

\subsubsection{Roots}

\begin{lstlisting}
isqrt(x::fmpz)
\end{lstlisting}

\desc{Return the square root of $x$, rounded down to the nearest integer. If $x < 0$
a \code{DomainError()} is thrown.}

\begin{lstlisting}
isqrtrem(x::fmpz)
\end{lstlisting}

\desc{Return a tuple $(s, r)$ consisting of the square root of $x$, rounded down to the 
nearest integer and the remainder, i.e. $r = x - s^2$. If $x < 0$ a \code{DomainError()}
is thrown.}

\begin{lstlisting}
root(x::fmpz, n::Int)
\end{lstlisting}

\desc{Return the $n$-th root of $x$, rounded down to the nearest integer. If $x < 0$ and
$n$ is even, a \code{DomainError()} is thrown. If $n \leq 0$ a \code{DomainError()} is
thrown.}

\textbf{Examples.}

Here are some examples of the root taking functions.

\begin{lstlisting}
s = isqrt(fmpz(12))
s, r = isqrtrem(fmpz(12))
r = root(fmpz(1000), 3)
\end{lstlisting}

\subsubsection{Extended GCD}

\begin{lstlisting}
gcdx(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Return a tuple $(g, s, t)$ consisting of the greatest common divisor of $a$ and $b$
and values $s$ and $t$ such that $g = as + bt$, with $-b \leq s \leq b$ and 
$-a \leq t \leq a$.}

\begin{lstlisting}
gcdinv(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Return a tuple $(g, s)$ consisting of the greatest common divisor of $a$ and $b$
and a value $0 \leq s < b$ such that there exists a value $t$ such that 
$g = as + bt$. If $a < 0$ or $b < a$, a \code{DomainError()} is thrown.}

\textbf{Examples.}

Here are some examples of the extended GCD functions.

\begin{lstlisting}
g, s, t = gcdx(fmpz(12), fmpz(5))
g, s = gcdinv(fmpz(5), fmpz(12))
\end{lstlisting}

\subsubsection{Bit twiddling}

Various functions are provided to deal with bignums on a binary bit level.

\begin{lstlisting}
popcount(x::fmpz)
\end{lstlisting}

\desc{Return the number of binary ones in the binary representation of $x$. If $x < 0$ the
function will return $0$. The result that is returned is of type \code{Int}.}

\begin{lstlisting}
prevpow2(x::fmpz)
\end{lstlisting}

\desc{Return the largest power of $2$ which does not exceed $x$. If $x < 0$ the result is
set to \code{-prevpow2(-x)}.}

\begin{lstlisting}
nextpow2(x::fmpz)
\end{lstlisting}

\desc{Return the smallest power of $2$ which is not less than $x$. If $x < 0$ the result is
set to \code{-nextpow2(-x)}.}

\begin{lstlisting}
trailing_zeros(x::fmpz)
\end{lstlisting}

\desc{Return the number of trailing zeros in the binary representation of the absolute
value of $x$.}

\begin{lstlisting}
clrbit!(x::fmpz, n::Int)
\end{lstlisting}

\desc{Set bit $n$ in the binary representation of the absolute value of $x$ to $0$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\begin{lstlisting}
setbit!(x::fmpz, n::Int)
\end{lstlisting}

\desc{Set bit $n$ in the binary representation of the absolute value of $x$ to $1$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\begin{lstlisting}
combit!(x::fmpz, n::Int)
\end{lstlisting}

\desc{Complement bit $n$ in the binary representation of the absolute value of $x$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\textbf{Examples.}

Here are some examples of the bit twiddling functions.

\begin{lstlisting}
a = fmpz(12)

p = popcount(a)
b = nextpow2(a)
combit!(a, 2)
\end{lstlisting}

\subsubsection{Alternative bases}

\begin{lstlisting}
base(n::fmpz, b::Int)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in the given base $b$. Valid
bases are $2 \leq b \leq 62$. If an invalid base is applied an error is raised.}

\begin{lstlisting}
bin(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in binary, i.e. base $2$.}

\begin{lstlisting}
oct(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in octal, i.e. base $8$.}

\begin{lstlisting}
dec(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in decimal, i.e. base $10$.}

\begin{lstlisting}
hex(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in hexadecimal, i.e. base $16$.}

\begin{lstlisting}
ndigits(n::fmpz, b::Integer = 10)
\end{lstlisting}

\desc{Return an \code{Int} representing the number of digits required to represent the
absolute value of $n$ as a string in base $b$. The default is $b = 10$. Note that $0$
always requires one digit as a string.}

\begin{lstlisting}
nbits(n::fmpz)
\end{lstlisting}

\desc{Return an \code{Int} representing the number of bits required to represent the
absolute value of $n$ in binary. We take the convention that $0$ requires $0$ binary 
bits.}

\textbf{Examples.}

Here are some examples of the functions for alternative bases.

\begin{lstlisting}
a = fmpz(12)

s1 = bin(a)
s2 = base(a, 13)
n1 = nbits(a)
n2 = ndigits(a, 3)
\end{lstlisting}

\subsubsection{String I/O}

\begin{lstlisting}
string(x::fmpz)
\end{lstlisting}

\desc{Return a unicode string representation of the value of $x$ in decimal, including the sign
if $x < 0$.}

\textbf{Examples.}

Here is an example of string I/O.

\begin{lstlisting}
a = fmpz(12)

string(a)
\end{lstlisting}

\subsubsection{Modular arithmetic}

\begin{lstlisting}
mod(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return the Euclidean remainder of $a$ by $b$. If $m = 0$ a \code{DivideError()} is thrown.}

\begin{lstlisting}
powmod(x::fmpz, p::Int, m::fmpz)
powmod(x::fmpz, p::fmpz, m::fmpz)
\end{lstlisting}

\desc{Return $x^p \pmod{m}$. If $m \leq 0$ a \code{DomainError()} is thrown.}

\begin{lstlisting}
invmod(x::fmpz, m::fmpz)
\end{lstlisting}

\desc{Return $x^{-1} \pmod{m}$. If $m \leq 0$ a \code{DomainError()} is thrown. If
an impossible inverse is encountered, an exception is thrown.}

\begin{lstlisting}
gcdinv(x::fmpz, m::fmpz)
\end{lstlisting}

\desc{Returns the pair \code{g, xinv} where $g$ is the greatest common divisor of
$x$ and $m$ and \code{xinv} is $x^{-1} \pmod{m}$. If $m \leq 0$ a 
\code{DomainError()} is thrown.}

\begin{lstlisting}
sqrtmod(x::fmpz, m::fmpz)
\end{lstlisting}

\desc{Return the square root of $x$ modulo $m$. If $m \leq 0$ a \code{DomainError()}
is thrown. If $x$ is not a square modulo $m$, an exception is thrown. Requires $m$ to
be prime. This condition is not checked and an infinite loop may result if $m$ is
not prime.}

\begin{lstlisting}
crt(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, sign = false)
crt(r1::fmpz, m1::fmpz, r2::Int, m2::Int, sign = false)
\end{lstlisting}

\desc{Return a value $r$ such that $r \equiv r1 \pmod {m1}$ and $r \equiv r2 \pmod{m2}$.
If \code{sign = true} the value will be in the range \code{-m1*m2/2 < r <= m1*m2/2}. If
\code{sign = false} the value will be in the range \code{0 <= r < m1*m2}.}

\textbf{Examples.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
a = powmod(fmpz(12), fmpz(110), fmpz(13))
a = powmod(fmpz(12), 110, fmpz(13))
b = invmod(fmpz(12), fmpz(13))
c = sqrtmod(fmpz(12), fmpz(13))
d = crt(fmpz(5), fmpz(13), fmpz(7), fmpz(37), true)
\end{lstlisting}

\subsubsection{Number theoretic/combinatorial functions}

\begin{lstlisting}
divisible(x::fmpz, y::fmpz)
divisible(x::fmpz, y::Int)
\end{lstlisting}

\desc{Return \code{true} if $x$ is divisible by $y$, otherwise return \code{false}. If
$y = 0$ a \code{DivideError()} is raised.}

\begin{lstlisting}
issquare(x::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $x$ is a perfect square, otherwise return \code{false}.}

\begin{lstlisting}
isprime(x::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $x$ is prime, otherwise return \code{false}.}

\begin{lstlisting}
isprobabprime(x::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $x$ is very probably prime, otherwise return \code{false}.}

\begin{lstlisting}
remove(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Returns a pair $(n, z)$ where $n$ is an \code{Int} and $z$ a \code{fmpz} such that
$x = y^nz$ and $z$ is not divisible by $y$. If $y = 0$ a \code{DivideError()} is thrown.}

\begin{lstlisting}
divisor_lenstra(n::fmpz, r::fmpz, m::fmpz)
\end{lstlisting}

\desc{If $n$ has a factor which lies in the residue class $r \pmod{m}$ for $0 < r < m < n$,
this function returns such a factor. Otherwise it returns $0$. This is only efficient if 
$m$ is at least the cube root of $n$. We require gcd$(r, m) = 1$ and this condition is not
checked.}

\begin{lstlisting}
fac(n::Int)
\end{lstlisting}

\desc{Return as a \code{fmpz} the factorial of $n$, i.e. $n(n - 1)(n - 2)\ldots 1$.
If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
risingfac(x::fmpz, n::Int)
risingfac(x::Int, n::Int)
\end{lstlisting}

\desc{Return the rising factorial of $x$, i.e. $x(x + 1)(x + 2)\ldots (x + n - 1)$.
If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
primorial(n::Int)
\end{lstlisting}

\desc{Return as a \code{fmpz} the primorial of $n$, i.e. the product of all primes
less than or equal to $n$. If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
fib(n::Int)
\end{lstlisting}

\desc{Return the $n$-th element of the Fibonacci sequence, starting with 
\code{fib(1) = 1}, \code{fib(2) = 1} and following the recursion 
\code{fib(n) = fib(n - 1) + fib(n - 2)} for $n \geq 3$.
We return fib$(0) = 0$. If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
binom(n::Int, k::Int)
\end{lstlisting}

\desc{Return as a \code{fmpz} the binomial coefficient $\frac{n!}{(n - k)!k!}$. If
$n, k < 0$ or $k > n$ we return $0$.}

\begin{lstlisting}
moebiusmu(x::fmpz)
\end{lstlisting}

\desc{Returns the M\"{o}bius mu function of $x$ as an \code{Int}. The value returned is
either $-1$, $0$ or $1$. If $x < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
jacobi(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return the value of the Jacobi symbol $\ljk{x}{y}$. If $y \leq x$ or $x < 0$ we
throw a \code{DomainError()}.}

\begin{lstlisting}
sigma(x::fmpz, y::Int)
\end{lstlisting}

\desc{Return the value of the sigma function, i.e. $\sum_{0 < d \;| x} d^y$. If $y < 0$
we throw a \code{DomainError()}.}

\begin{lstlisting}
eulerphi(x::fmpz)
\end{lstlisting}

\desc{Return the value of the Euler phi function, i.e. the number of $0 < d \leq x$ such
that gcd$(d, x) = 1$. If $x < 0$ we throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of number theoretic and combinatorial functions.

\begin{lstlisting}
if isprime(fmpz(13))
   println("13 is prime")
end

n = fac(100)
s = sigma(fmpz(128), 10)
a = eulerphi(fmpz(12480))
\end{lstlisting}

\subsection{Flint polynomials over $\Z$: \code{fmpz_poly}}

The Flint integer polynomial type is \code{fmpz_poly}. Polynomials of this type are created
using the \code{PolynomialRing} constructor.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FmpzPolyRing}.

We describe functions for \code{fmpz_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are provided, as these are faster than first coercing
to a common ring and then applying the operator.

\begin{lstlisting}
+(x::fmpz_poly, y::Int)
+(x::fmpz_poly, y::fmpz)
+(x::Int, y::fmpz_poly)
+(x::fmpz, y::fmpz_poly)
\end{lstlisting}

\desc{Return the polynomial $x + y$.}

\begin{lstlisting}
-(x::fmpz_poly, y::Int)
-(x::fmpz_poly, y::fmpz)
-(x::Int, y::fmpz_poly)
-(x::fmpz, y::fmpz_poly)
\end{lstlisting}

\desc{Return the polynomial $x - y$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 2x + 1
g = x^2 - 7x + 4

h = f + 7
k = g - 7
l = fmpz(3) + f
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

\begin{lstlisting}
==(x::fmpz_poly, y::fmpz)
==(x::fmpz, y::fmpz_poly)
\end{lstlisting}

\desc{Return \code{true} if $x == y$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 2x + 1

f != fmpz(6)
fmpz(7) == R(7)
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::fmpz_poly, y::Int)
\end{lstlisting}

\desc{Return the quotient of $x$ by $y$, assuming the division is exact.}

\textbf{Examples.}

Here is an example of ad hoc division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 2x + 1

g = divexact(f*3, 3)
\end{lstlisting}

\subsubsection{Content, primitive part and GCD}

\begin{lstlisting}
content(f::fmpz_poly)
\end{lstlisting}

\desc{Return the content of the polynomial $f$, i.e. the greatest common divisor of its
coefficients.}

\begin{lstlisting}
primpart(f::fmpz_poly)
\end{lstlisting}

\desc{Return the primitive part of the polynomial $f$, i.e. the polynomial divided by
its content.}

\begin{lstlisting}
gcd(f::fmpz_poly, g::fmpz_poly)
\end{lstlisting}

\desc{Return the greatest common divisor of the polynomials $f$ and $g$.}

\textbf{Examples.}

Here is an example of ad hoc division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^2 + 2x + 1
g = x^3 + 3x + 1
h = x + 1

k = content(3*f)
l = primpart(3*f)
m = gcd(f*h, g*h)
\end{lstlisting}

\subsubsection{Signature}

\begin{lstlisting}
signature(f::fmpz_poly)
\end{lstlisting}

\desc{Computes the signature of the polynomial $f$, i.e. a tuple $(r, s)$ where $r$ is
the number of real roots and $s$ is half the number of complex roots.}

\textbf{Examples.}

Here is an example of signature.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 3x + 1

(r, s) = signature(f)
\end{lstlisting}

\subsubsection{Special polynomials}

The following functions compute univariate special polynomials over \code{fmpz}. It is expected
that the final argument in each of these function is the generator of the polynomial ring.

\begin{lstlisting}
chebyshev_t(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $T_n(x)$, defined by 
$T_n(x) = \cos(n \cos^{-1}(x))$.}

\begin{lstlisting}
chebyshev_u(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $U_n(x)$, defined by 
$(n+1) U_n(x) = T'_{n+1}(x)$.}

\begin{lstlisting}
cyclotomic(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the $n$th cyclotomic polynomial, defined as
$$\Phi_n(x) = \prod_{\omega} (x-\omega),$$ where $\omega$ runs over all the 
$n$th primitive roots of unity.}

\begin{lstlisting}
swinnerton_dyer(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Swinnerton-Dyer polynomial $S_n$, defined as the integer 
polynomial $$S_n = \prod (x \pm \sqrt{2} \pm \sqrt{3}
\pm \sqrt{5} \pm \ldots \pm \sqrt{p_n})$$ where $p_n$ denotes the $n$-th prime 
number and all combinations of signs are taken. This polynomial has degree $2^n$
and is irreducible over the integers (it is the minimal polynomial of 
$\sqrt{2} + \ldots + \sqrt{p_n}$)}

\begin{lstlisting}
cos_minpoly{S}(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the minimal polynomial of $2 \cos(2 \pi / n)$. For suitable choice of 
$n$, this gives the minimal polynomial of $2 \cos(a \pi)$ or $2 \sin(a \pi)$ for any
rational $a$.}

\begin{lstlisting}
theta_qexp{S}(r::Int, n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the $q$-expansion to length $n$ of the Jacobi theta function raised to 
the power $r$, i.e. $\vartheta(q)^r$ where 
$\vartheta(q) = 1 + \sum_{k=1}^{\infty} q^{k^2}$.}

\begin{lstlisting}
eta_qexp{S}(r::Int, n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the $q$-expansion to length $n$ of the Dedekind eta function (without 
the leading factor $q^{1/24}$) raised to the power $r$, i.e. $(q^{-1/24} \eta(q))^r 
= \prod_{k=1}^{\infty} (1 - q^k)^r$.

In particular, $r = -1$ gives the generating function of the partition function $p(k)$, 
and $r = 24$ gives, after multiplication by $q$, the modular discriminant $\Delta(q)$ 
which generates the Ramanujan tau function $\tau(k)$.}

\textbf{Examples.}

Here are some examples of computing special polynomials.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = chebyshev_t(20, x)
g = chebyshev_u(15, x)
h = cyclotomic(120, x)
j = swinnerton_dyer(5, x)
k = cos_minpoly(30, x)
l = theta_qexp(3, 30, x)
m = eta_qexp(24, 30, x)
\end{lstlisting}

\subsection{Flint polynomials over $\Z/n\Z$ (multiprecision $n$): \code{fmpz_mod_poly}}

The Flint type for polynomials over $\Z/n\Z$ for multiprecision $n$ is \code{fmpz_mod_poly}.
Polynomials of this type are created using the \code{PolynomialRing} constructor. They are
automatically created if the modulus $n$ doesn't fit into a \code{UInt}.

\begin{lstlisting}
R = ResidueRing(ZZ, 123456789012345678901)
S, x = PolynomialRing(R, "x")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FmpzModPolyRing}.

We describe functions for \code{fmpz_mod_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the constructors below $S$ is assumed to be an \code{FmpzModPolyRing} as constructed above.

\begin{lstlisting}
S(arr::Array{fmpz, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those in the array, reduced modulo the
modulus of the base ring of $S$.}

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ whose coefficient is the given integer reduced
modulo the modulus of the base ring of $S$ (or the zero polynomial if $a$ is zero when
reduced modulo the modulus).}

\begin{lstlisting}
S(p::fmpz_poly)
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those of the given polynomial, but
reduced modulo the modulus of the base ring of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
R = ResidueRing(ZZ, 123456789012345678901)
S, x = PolynomialRing(R, "x")

a = S()
b = S(x + 1)
c = S([R(1), R(0), R(2)])
d = S(c)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::fmpz_mod_poly, y::Residue{fmpz})
*(x::Residue{fmpz}, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return the polynomial $xy$.}

\begin{lstlisting}
+(x::fmpz_mod_poly, y::Residue{fmpz})
+(x::Residue{fmpz}, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return the polynomial $x + y$.}

\begin{lstlisting}
-(x::fmpz_mod_poly, y::Residue{fmpz})
-(x::Residue{fmpz}, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return the polynomial $x - y$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 2

   a = R(12) + g
   b = f - R(12)
   c = f*R(12)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

\begin{lstlisting}
==(x::fmpz_mod_poly, y::Residue{fmpz})
==(x::Residue{fmpz}, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return \code{true} if $x$ and $y$ are equal, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 2

   S(7) == R(7)
   R(7) != x + 1
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::fmpz_mod_poly, y::Residue{fmpz})
\end{lstlisting}

\desc{Divide the polynomial $x$ by the residue $y$, assuming the division is exact.}

\textbf{Examples.}

Here is an example of ad hoc exact division.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   
   a = divexact(R(7)*f, R(7)) 
\end{lstlisting}

\subsubsection{Modular arithmetic}

\begin{lstlisting}
powmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return $x^e \pmod{y}$.}

\textbf{Examples.}

Here is an example of modular arithmetic.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 1
   
   a = powmod(f, fmpz(7), g) 
\end{lstlisting}

\subsubsection{Lifting}

\begin{lstlisting}
lift(x::FmpzPolyRing, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Lift the polynomial $y$ over $\Z/n\Z$ to a polynomial over $\Z$ in the given ring.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   T, y = PolynomialRing(ZZ, "y")

   f = x^2 + 2x + 1

   a = lift(T, f) 
\end{lstlisting}

\subsubsection{Irreducibility testing}

\begin{lstlisting}
isirreducible(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return \code{true} if the polynomial $x$ is irreducible, otherwise return \code{false}.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1

   isirreducible(f) == false
\end{lstlisting}

\subsubsection{Squarefree testing}

\begin{lstlisting}
issquarefree(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return \code{true} if the polynomial $x$ is squarefree, otherwise return \code{false}.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1

   issquarefree(f) == false
\end{lstlisting}

\subsubsection{Factorisation}

\begin{lstlisting}
factor(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return an array containing the factorisation of the given polynomial. The entries in
the array are tuples $(p, e)$ consisting of irreducible polynomials $p$ and their exponent
$e$ in the factorisation.}

\begin{lstlisting}
factor_squarefree(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return an array containing the squarefree factorisation of the given polynomial. The
entries in the array are tuples $(p, e)$ consisting of squarefree polynomials $p$ and their
exponent $e$ in the factorisation.}

\begin{lstlisting}
factor_distinct_deg(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return an array containing the distinct degree factorisation of the given polynomial.
The entries in the array are tuples $(p, e)$ consisting of polynomials $p$ which are the
products of all the irreducible polynomials of the given degree $e$ in the factorisation.}

\begin{lstlisting}
factor_shape(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return an array containing the shape of the factorisation of the given polynomial.
The entries in the array are tuples $(d, e)$ consisting of the degrees $d$ of the
irreducible polynomials and their exponents $e$ in the factorisation.}

\textbf{Examples.}

Here are some examples of factoring.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 1

   R = factor(f*g)
   S = factor_squarefree(f*g)
   T = factor_distinct_deg((x + 1)*g*(x^5+x+1))
   U = factor_shape(f*g)
\end{lstlisting}

\subsection{Flint polynomials over $\Z/n\Z$ (small $n$): \code{nmod_poly}}

The Flint type for polynomials over $\Z/n\Z$ for small $n$ is \code{nmod_poly}. Polynomials
of this type are created using the \code{PolynomialRing} constructor. They are automatically
created if the modulus $n$ fits into a \code{UInt}.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")
\end{lstlisting}

Polynomials in this ring have parent of type \code{NmodPolyRing}.

We describe functions for \code{nmod_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the constructors below $S$ is assumed to be an \code{NmodPolyRing} as constructed above.

\begin{lstlisting}
S(arr::Array{UInt, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those in the array.}

\begin{lstlisting}
S(arr::Array{fmpz, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those in the array, reduced modulo the
modulus of the base ring of $S$.}

\begin{lstlisting}
S(a::UInt)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ whose coefficient is the given integer (or the
zero polynomial if $a$ is zero).}

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ whose coefficient is the given integer reduced
modulo the modulus of the base ring of $S$ (or the zero polynomial if $a$ is zero when
reduced modulo the modulus).}

\begin{lstlisting}
S(p::fmpz_poly)
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those of the given polynomial, but
reduced modulo the modulus of the base ring of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")

a = S()
b = S(x + 1)
c = S([R(1), R(0), R(2)])
d = S(c)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::nmod_poly, y::Residue{fmpz})
*(x::Residue{fmpz}, y::nmod_poly)
\end{lstlisting}

\desc{Return the polynomial $xy$.}

\begin{lstlisting}
+(x::nmod_poly, y::Residue{fmpz})
+(x::Residue{fmpz}, y::nmod_poly)
\end{lstlisting}

\desc{Return the polynomial $x + y$.}

\begin{lstlisting}
-(x::nmod_poly, y::Residue{fmpz})
-(x::Residue{fmpz}, y::nmod_poly)
\end{lstlisting}

\desc{Return the polynomial $x - y$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 2

   a = R(12) + g
   b = f - R(12)
   c = f*R(12)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

\begin{lstlisting}
==(x::nmod_poly, y::Residue{fmpz})
==(x::Residue{fmpz}, y::nmod_poly)
\end{lstlisting}

\desc{Return \code{true} if $x$ and $y$ are equal, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
   R = ResidueRing(ZZ, 13)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 2

   S(7) == R(7)
   R(7) != x + 1
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::nmod_poly, y::Residue{fmpz})
\end{lstlisting}

\desc{Divide the polynomial $x$ by the residue $y$, assuming the division is exact.}

\textbf{Examples.}

Here is an example of ad hoc exact division.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   
   a = divexact(R(7)*f, R(7)) 
\end{lstlisting}

\subsubsection{Interpolation}

\begin{lstlisting}
divexact(R::NmodPolyRing, xval::Array{Residue{fmpz}, 1}, yval::Array{Residue{fmpz}, 1})
\end{lstlisting}

\desc{Returns the unique polynomial in the given ring $R$ of degree at most equal to the
length of the two supplied arrays, which interpolates the values in the array \code{yval}
at the values in the array \code{xval}.}

\textbf{Examples.}

Here is an example of interpolation.

\begin{lstlisting}
  R = ResidueRing(ZZ, 23)
  S, x = PolynomialRing(R, "x")

  xval = [ R(0), R(1), R(2), R(3) ]

  yval = [ R(0), R(1), R(4), R(9) ] 

  f = interpolate(S, xval, yval)
\end{lstlisting}

\subsubsection{Inflation and deflation}

\begin{lstlisting}
inflate(f::nmod_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x)$, returns $f(x^n)$.}

\begin{lstlisting}
deflate(f::nmod_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x^n)$, returns $f(x)$.}

\textbf{Examples.}

Here is an example of inflation and deflation.

\begin{lstlisting}
  R = ResidueRing(ZZ, 23)
  S, x = PolynomialRing(R, "x")

  f = x^6 + x^4 + 2 *x^2 

  g = inflate(f, 2)
  h = deflate(g, 2)
\end{lstlisting}

\subsubsection{Lifting}

\begin{lstlisting}
lift(x::FmpzPolyRing, y::nmod_poly)
\end{lstlisting}

\desc{Lift the polynomial $y$ over $\Z/n\Z$ to a polynomial over $\Z$ in the given ring.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   T, y = PolynomialRing(ZZ, "y")

   f = x^2 + 2x + 1

   a = lift(T, f) 
\end{lstlisting}

\subsubsection{Irreducibility testing}

\begin{lstlisting}
isirreducible(x::nmod_poly)
\end{lstlisting}

\desc{Return \code{true} if the polynomial $x$ is irreducible, otherwise return \code{false}.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1

   isirreducible(f) == false
\end{lstlisting}

\subsubsection{Squarefree testing}

\begin{lstlisting}
issquarefree(x::nmod_poly)
\end{lstlisting}

\desc{Return \code{true} if the polynomial $x$ is squarefree, otherwise return \code{false}.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1

   issquarefree(f) == false
\end{lstlisting}

\subsubsection{Factorisation}

\begin{lstlisting}
factor(x::nmod_poly)
\end{lstlisting}

\desc{Return an array containing the factorisation of the given polynomial. The entries in
the array are tuples $(p, e)$ consisting of irreducible polynomials $p$ and their exponent
$e$ in the factorisation.}

\begin{lstlisting}
factor_squarefree(x::nmod_poly)
\end{lstlisting}

\desc{Return an array containing the squarefree factorisation of the given polynomial. The
entries in the array are tuples $(p, e)$ consisting of squarefree polynomials $p$ and their
exponent $e$ in the factorisation.}

\begin{lstlisting}
factor_distinct_deg(x::nmod_poly)
\end{lstlisting}

\desc{Return an array containing the distinct degree factorisation of the given polynomial.
The entries in the array are tuples $(p, e)$ consisting of polynomials $p$ which are the
products of all the irreducible polynomials of the given degree $e$ in the factorisation.}

\begin{lstlisting}
factor_shape(x::nmod_poly)
\end{lstlisting}

\desc{Return an array containing the shape of the factorisation of the given polynomial.
The entries in the array are tuples $(d, e)$ consisting of the degrees $d$ of the
irreducible polynomials and their exponents $e$ in the factorisation.}

\textbf{Examples.}

Here are some examples of factoring.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 1

   R = factor(f*g)
   S = factor_squarefree(f*g)
   T = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))
   U = factor_shape(f*g)
\end{lstlisting}

\subsection{Flint polynomials over $\Q$: \code{fmpq_poly}}

The Flint type for polynomials over $\Q$ is \code{fmpq_poly}.
Polynomials of this type are created using the \code{PolynomialRing} constructor with
\code{FlintRationalField()} as an argument (the same as \code{QQ}, by default).  

\begin{lstlisting}
S, x = PolynomialRing(QQ, "x")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FmpqPolyRing}.

We describe functions for \code{fmpq_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the following constructors we assume that $S$ is an \code{FmpqPolyRing} parent 
object, as created by the above construction for example.

\begin{lstlisting}
S(a::Int)
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ with $a$ as its only coefficient (or
the zero polynomial if $a = 0$).}

\begin{lstlisting}
S(a::fmpz_poly)
\end{lstlisting}

\desc{Coerce the given polynomial into the ring $S$, i.e. coerce its coefficients
into $\Q$ and change the variable to that of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = S(12)
   b = S(fmpz(12))
   
   R, y = PolynomialRing(ZZ, "y")

   c = S(3y^3 + 2y + 1)
\end{lstlisting}

\subsubsection{Basic manipulation}

Internally, Flint stores \code{fmpq_poly}'s as an array of integers and a single
common denominator.

\begin{lstlisting}
den(a::fmpq_poly)
\end{lstlisting}

\desc{Return the common denominator of the coefficients of the polynomial $a$.}

\textbf{Examples.}

Here is an example of basic manipulation.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = den(-fmpz(12)//7*x + 1)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
*(a::fmpq_poly, b::fmpq)
*(a::fmpq, b::fmpq_poly)
\end{lstlisting}

\desc{Return $ab$.}

\begin{lstlisting}
+(a::fmpq_poly, b::Int)
+(a::Int, b::fmpq_poly)
+(a::fmpq_poly, b::fmpz)
+(a::fmpz, b::fmpq_poly)
+(a::fmpq_poly, b::fmpq)
+(a::fmpq, b::fmpq_poly)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fmpq_poly, b::Int)
-(a::Int, b::fmpq_poly)
-(a::fmpq_poly, b::fmpz)
-(a::fmpz, b::fmpq_poly)
-(a::fmpq_poly, b::fmpq)
-(a::fmpq, b::fmpq_poly)
\end{lstlisting}

\desc{Return $a - b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = 7y^2 + 3y + 2

   b = a + 7
   c = fmpz(7) - a
   d = fmpq(2, 3)*a
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

The following ad hoc binary comparisons are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
==(a::fmpq_poly, b::fmpq)
==(a::fmpq, b::fmpq_poly)
\end{lstlisting}

\desc{Return \code{true} if $a$ is equal to $b$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = 7y^2 + 3y + 2

   a != fmpq(2, 3)
   fmpq(2, 3) == S(fmpq(2, 3))
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(a::fmpq_poly, b::Int)
divexact(a::fmpq_poly, b::fmpz)
\end{lstlisting}

\desc{Return the quotient of $a$ by $b$. A \code{DivideError()} is raised if $b = 0$.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = 7y^2 + 3y + 2

   b = divexact(a, 7)
   c = divexact(a, fmpz(11))
\end{lstlisting}

\subsection{Flint polynomials over $\F_{p^k}$ (multiprecision $p$): \code{fq_poly}}

The Flint type for polynomials over $\F_{p^k}$ for multiprecision $p$ is \code{fq_poly}.
Polynomials of this type are created using the \code{PolynomialRing} constructor with
an \code{FqFiniteField} parent object as parameter. For example

\begin{lstlisting}
R, x = FiniteField(fmpz(23), 5, "x")
S, y = PolynomialRing(R, "y")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FqPolyRing}.

We describe functions for \code{fq_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the following constructors we assume that $S$ is an \code{FqPolyRing} parent 
object, as created by the above construction for example.

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ with $a$ as its only coefficient (or
the zero polynomial if $a = 0$).}

\begin{lstlisting}
S(a::Array{fmpz, 1})
S{T <: Integer}(a::Array{T, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are the integers in the given
array (thought of as elements of the finite field).}

\begin{lstlisting}
S(a::fmpz_poly)
\end{lstlisting}

\desc{Coerce the given polynomial into the ring $S$, i.e. coerce its coefficients
into the finite field and change the variable to that of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
   R, x = FiniteField(fmpz(23), 5, "x")
   S, y = PolynomialRing(R, "y")

   a = S(fmpz(12))
   b = S([1, 2, 3])
   c = S(3y^3 + 2y + 1)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
*(a::fq_poly, b::fq)
*(a::fq, b::fq_poly)
*(a::fq_poly, b::Integer)
*(a::Integer, b::fq_poly)
\end{lstlisting}

\desc{Return $ab$.}

\begin{lstlisting}
+(a::fq_poly, b::Int)
+(a::Int, b::fq_poly)
+(a::fq_poly, b::Integer)
+(a::Integer, b::fq_poly)
+(a::fq_poly, b::fmpz)
+(a::fmpz, b::fq_poly)
+(a::fq_poly, b::fq)
+(a::fq, b::fq_poly)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fq_poly, b::Int)
-(a::Int, b::fq_poly)
-(a::fq_poly, b::Integer)
-(a::Integer, b::fq_poly)
-(a::fq_poly, b::fmpz)
-(a::fmpz, b::fq_poly)
-(a::fq_poly, b::fq)
-(a::fq, b::fq_poly)
\end{lstlisting}

\desc{Return $a - b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, x = FiniteField(fmpz(23), 5, "x")
   S, y = PolynomialRing(R, "y")

   a = 7y^2 + 3y + 2

   b = a + 7
   c = fmpz(7) - a
   d = (x + 1)*a
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

The following ad hoc binary comparisons are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
==(a::fq_poly, b::fq)
==(a::fq, b::fq_poly)
==(a::fq_poly, b::fmpz)
==(a::fmpz, b::fq_poly)
\end{lstlisting}

\desc{Return \code{true} if $a$ is equal to $b$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
   R, x = FiniteField(fmpz(23), 5, "x")
   S, y = PolynomialRing(R, "y")

   a = 7y^2 + 3y + 2

   a != x + 1
   x + 1 == S(x + 1)
   a != fmpz(11)
\end{lstlisting}

\subsubsection{Inflation and deflation}

\begin{lstlisting}
inflate(f::fq_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x)$, returns $f(x^n)$.}

\begin{lstlisting}
deflate(f::fq_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x^n)$, returns $f(x)$.}

\textbf{Examples.}

Here is an example of inflation and deflation.

\begin{lstlisting}
  R, x = FiniteField(fmpz(23), 5, "x")
  S, y = PolynomialRing(R, "y")

  a = 7y^2 + 3y + 2

  g = inflate(f, 2)
  h = deflate(g, 2)
\end{lstlisting}

\subsubsection{Factorisation}

\begin{lstlisting}
factor(x::fq_poly)
\end{lstlisting}

\desc{Return an array containing the factorisation of the given polynomial. The entries in
the array are tuples $(p, e)$ consisting of irreducible polynomials $p$ and their exponent
$e$ in the factorisation.}

\begin{lstlisting}
factor_distinct_deg(x::fq_poly)
\end{lstlisting}

\desc{Return an array containing the distinct degree factorisation of the given polynomial.
The entries in the array are tuples $(p, e)$ consisting of polynomials $p$ which are the
products of all the irreducible polynomials of the given degree $e$ in the factorisation.}

\textbf{Examples.}

Here are some examples of factoring.

\begin{lstlisting}
   R, x = FiniteField(fmpz(23), 5, "x")
   S, y = PolynomialRing(R, "y")

   f = 7y^2 + 3y + 2
   g = 11y^3 - 2y^2 + 5

   A = factor(f*g)
   B = factor_distinct_deg((y + 1)*g*(y^5+y^3+y+1))
\end{lstlisting}

\subsection{Flint polynomials over $\F_{p^k}$ (small $p$): \code{fq_nmod_poly}}

The Flint type for polynomials over $\F_{p^k}$ for $p$ that fits in an \code{Int} is
\code{fq_poly}. Polynomials of this type are created using the \code{PolynomialRing}
constructor with an \code{FqNmodFiniteField} parent object as parameter. For example

\begin{lstlisting}
R, x = FiniteField(23, 5, "x")
S, y = PolynomialRing(R, "y")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FqNmodPolyRing}.

We describe functions for \code{fq_nmod_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the following constructors we assume that $S$ is an \code{FqNmodPolyRing} parent 
object, as created by the above construction for example.

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ with $a$ as its only coefficient (or
the zero polynomial if $a = 0$).}

\begin{lstlisting}
S(a::Array{fmpz, 1})
S{T <: Integer}(a::Array{T, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are the integers in the given
array (thought of as elements of the finite field).}

\begin{lstlisting}
S(a::fmpz_poly)
\end{lstlisting}

\desc{Coerce the given polynomial into the ring $S$, i.e. coerce its coefficients
into the finite field and change the variable to that of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
   R, x = FiniteField(23, 5, "x")
   S, y = PolynomialRing(R, "y")

   a = S(fmpz(12))
   b = S([1, 2, 3])
   c = S(3y^3 + 2y + 1)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
*(a::fq_nmod_poly, b::fq_nmod)
*(a::fq_nmod, b::fq_poly_nmod)
*(a::fq_nmod_poly, b::Integer)
*(a::Integer, b::fq_nmod_poly)
\end{lstlisting}

\desc{Return $ab$.}

\begin{lstlisting}
+(a::fq_nmod_poly, b::Int)
+(a::Int, b::fq_nmod_poly)
+(a::fq_nmod_poly, b::Integer)
+(a::Integer, b::fq_nmod_poly)
+(a::fq_nmod_poly, b::fmpz)
+(a::fmpz, b::fq_nmod_poly)
+(a::fq_nmod_poly, b::fq_nmod)
+(a::fq_nmod, b::fq_nmod_poly)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fq_nmod_poly, b::Int)
-(a::Int, b::fq_nmod_poly)
-(a::fq_nmod_poly, b::Integer)
-(a::Integer, b::fq_nmod_poly)
-(a::fq_nmod_poly, b::fmpz)
-(a::fmpz, b::fq_nmod_poly)
-(a::fq_nmod_poly, b::fq_nmod)
-(a::fq_nmod, b::fq_nmod_poly)
\end{lstlisting}

\desc{Return $a - b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, x = FiniteField(23, 5, "x")
   S, y = PolynomialRing(R, "y")

   a = 7y^2 + 3y + 2

   b = a + 7
   c = fmpz(7) - a
   d = (x + 1)*a
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

The following ad hoc binary comparisons are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
==(a::fq_nmod_poly, b::fq_nmod)
==(a::fq_nmod, b::fq_nmod_poly)
==(a::fq_nmod_poly, b::fmpz)
==(a::fmpz, b::fq_nmod_poly)
\end{lstlisting}

\desc{Return \code{true} if $a$ is equal to $b$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
   R, x = FiniteField(23, 5, "x")
   S, y = PolynomialRing(R, "y")

   a = 7y^2 + 3y + 2

   a != x + 1
   x + 1 == S(x + 1)
   a != fmpz(11)
\end{lstlisting}

\subsubsection{Inflation and deflation}

\begin{lstlisting}
inflate(f::fq_nmod_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x)$, returns $f(x^n)$.}

\begin{lstlisting}
deflate(f::fq_nmod_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x^n)$, returns $f(x)$.}

\textbf{Examples.}

Here is an example of inflation and deflation.

\begin{lstlisting}
  R, x = FiniteField(23, 5, "x")
  S, y = PolynomialRing(R, "y")

  a = 7y^2 + 3y + 2

  g = inflate(f, 2)
  h = deflate(g, 2)
\end{lstlisting}

\subsubsection{Factorisation}

\begin{lstlisting}
factor(x::fq_nmod_poly)
\end{lstlisting}

\desc{Return an array containing the factorisation of the given polynomial. The entries in
the array are tuples $(p, e)$ consisting of irreducible polynomials $p$ and their exponent
$e$ in the factorisation.}

\begin{lstlisting}
factor_distinct_deg(x::fq_nmod_poly)
\end{lstlisting}

\desc{Return an array containing the distinct degree factorisation of the given polynomial.
The entries in the array are tuples $(p, e)$ consisting of polynomials $p$ which are the
products of all the irreducible polynomials of the given degree $e$ in the factorisation.}

\textbf{Examples.}

Here are some examples of factoring.

\begin{lstlisting}
   R, x = FiniteField(23, 5, "x")
   S, y = PolynomialRing(R, "y")

   f = 7y^2 + 3y + 2
   g = 11y^3 - 2y^2 + 5

   A = factor(f*g)
   B = factor_distinct_deg((y + 1)*g*(y^5+y^3+y+1))
\end{lstlisting}

\subsection{Flint power series over $\Z$: \code{fmpz_series}}

Flint doesn't have a module for power series over $\Z$, but the \code{fmpz_poly}
module contains code for power series operations. In Nemo, for the purposes of
simplicity, we deal with Flint as though it has a module called \code{fmpz_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fmpz_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor.
It takes a maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FmpzSeriesRing}.

Currently the \code{fmpz_series} module provides nothing additional on top of
the functionality that is described for generic power series.

\subsection{Flint power series over $\Z/n\Z$ (multiprecision $n$): \code{fmpz_mod_series}}

Flint doesn't have a module for power series over $\Z/n\Z$, but the \code{fmpz_mod_poly}
module contains code for power series operations. In Nemo, for the purposes of
simplicity, we deal with Flint as though it has a module called \code{fmpz_mod_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fmpz_mod_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor.
It takes a maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R = ResidueRing(ZZ, 123456789012345678949)
S, x = PowerSeriesRing(R, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FmpzModSeriesRing}.

We list only the functionality that the \code{fmpz_mod_series} module provides on top of
the functionality that is described for generic power series.

\subsubsection{Constructors}

In the following we assume that $S$ is a power series ring parent object as created
by the construction above, for example.

\begin{lstlisting}
S(a::Array{Residue{fmpz}, 1}, n::Int, p::Int)
\end{lstlisting}

\desc{Create the power series in the ring $S$ whose coefficients are the entries in
the array $a$, reduced modulo the modulus of the residue ring. The length of the
array is specified by $n$, though $n$ can be less than this (remaining entries in the
array are ignored) and $p$ gives the precision of the power series created.}

\textbf{Examples.}

Here are some examples of power series constructors.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PowerSeriesRing(R, 30, "x")

   f = S([R(0), R(3), R(1)], 3, 5)
\end{lstlisting}

\subsection{Flint power series over $\Q$: \code{fmpq_series}}

Flint doesn't have a module for power series over $\Q$, but the \code{fmpq_poly}
module contains code for power series operations. In Nemo, for the purposes of
simplicity, we deal with Flint as though it has a module called \code{fmpq_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fmpq_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor.
It takes a maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R, x = PowerSeriesRing(QQ, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FmpqSeriesRing}.

We describe only the functions which are different to those described for generic
power series.

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::fmpq_series, y::fmpq)
*(x::fmpq, y::fmpq_series)
\end{lstlisting}

\desc{Return $xy$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, x = PowerSeriesRing(QQ, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = a*fmpq(2, 3)

   c = fmpq(2, 3)*a
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
exp(x::fmpq_series)
\end{lstlisting}

\desc{Compute the exponential of the given power series. The constant term must be $0$.}

\begin{lstlisting}
log(x::fmpq_series)
\end{lstlisting}

\desc{Compute the logarithm of the given power series. The constant term must be $1$.}

\begin{lstlisting}
sin(x::fmpq_series)
cos(x::fmpq_series)
tan(x::fmpq_series)
asin(x::fmpq_series)
atan(x::fmpq_series)
\end{lstlisting}

\desc{Compute the respective trigonometric series by substituting the given power series.
The constant term must be $0$.}

\begin{lstlisting}
sinh(x::fmpq_series)
cosh(x::fmpq_series)
tanh(x::fmpq_series)
asinh(x::fmpq_series)
atanh(x::fmpq_series)
\end{lstlisting}

\desc{Compute the respective hyperbolic trigonometric series by substituting the given power
series. The constant term must be $0$.}

\begin{lstlisting}
sqrt(x::fmpq_series)
\end{lstlisting}

\desc{Compute the square root of the given power series. The constant term must be $1$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, x = PowerSeriesRing(QQ, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   b = x + 2x^2 + 5x^3 + O(x^5)

   c = exp(b)
   d = log(a)
   f = sqrt(a)
   g = sin(b)
   h = atanh(b)   
\end{lstlisting}

\subsection{Flint power series over $\F_{p^k}$ (multiprecision $p$): \code{fq_series}}

Flint doesn't have a module for power series over $\F_{p^k}$, but the \code{fq_poly}
module contains code for power series operations. In Nemo, for the purposes of
simplicity, we deal with Flint as though it has a module called \code{fq_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fq_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor when
it is passed an \code{FqFiniteField} parent object as argument. The function also takes a
maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R, t = FiniteField(fmpz(23), 5, "t")
S, x = PowerSeriesRing(R, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FqSeriesRing}.

We describe only the functions which are different to those described for generic
power series.

\subsubsection{Constructors}

In the constructor below we assume $S$ is an \code{FqSeriesRing} parent object, as
constructed above for example. We assume the maximum precision of the power series
for this object to be $k$.

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the power series $a + O(x^k)$.}

\textbf{Examples.}

Here is an example of a constructor.

\begin{lstlisting}
   R, t = FiniteField(fmpz(23), 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = S(fmpz(12))
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::fq_series, y::fq)
*(x::fq, y::fq_series)
\end{lstlisting}

\desc{Return $xy$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, t = FiniteField(fmpz(23), 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = a*(t^2 + 1)

   c = 2t*a
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::fq_series, y::fq)
\end{lstlisting}

\desc{Return $x/y$. If $y = 0$ this raises a \code{DivideError()}.}

\textbf{Examples.}

Here is an example of ad hoc exact division.

\begin{lstlisting}
   R, t = FiniteField(fmpz(23), 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = divexact(a, t^2 + 1)
\end{lstlisting}

\subsection{Flint power series over $\F_{p^k}$ (small $p$): \code{fq_nmod_series}}

Flint doesn't have a module for power series over $\F_{p^k}$ for small $p$, but the
\code{fq_nmod_poly} module contains code for power series operations. In Nemo, for the
purposes of simplicity, we deal with Flint as though it has a module called
\code{fq_nmod_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fq_nmod_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor when
it is passed an \code{FqNmodFiniteField} parent object as argument. The function also
takes a maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R, t = FiniteField(23, 5, "t")
S, x = PowerSeriesRing(R, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FqNmodSeriesRing}.

We describe only the functions which are different to those described for generic
power series.

\subsubsection{Constructors}

In the constructor below we assume $S$ is an \code{FqNmodSeriesRing} parent object, as
constructed above for example. We assume the maximum precision of the power series
for this object to be $k$.

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the power series $a + O(x^k)$.}

\textbf{Examples.}

Here is an example of a constructor.

\begin{lstlisting}
   R, t = FiniteField(23, 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = S(fmpz(12))
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::fq_nmod_series, y::fq_nmod)
*(x::fq_nmod, y::fq_nmod_series)
\end{lstlisting}

\desc{Return $xy$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, t = FiniteField(23, 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = a*(t^2 + 1)

   c = 2t*a
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::fq_nmod_series, y::fq_nmod)
\end{lstlisting}

\desc{Return $x/y$. If $y = 0$ this raises a \code{DivideError()}.}

\textbf{Examples.}

Here is an example of ad hoc exact division.

\begin{lstlisting}
   R, t = FiniteField(23, 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = divexact(a, t^2 + 1)
\end{lstlisting}

\section{Flint fields}

Flint provides implementations of various explicit fields. We describe their
Nemo wrappers here.

\subsection{Flint rationals ($\Q$): \code|fmpq|}

Flint provides the module \code{fmpq} for rational numbers. The type of Flint rationals
in Nemo is also given the name \code{fmpq}.

The parent object for Flint rationals is of type \code{FlintRationalField}, which
belongs to the \code{Field} type class. Rational number objects have type \code{fmpq}
which belongs to the \code{FractionElem} type class, which in turn belongs to 
\code{FieldElem}.

The parent object for the rationals can be constructed using the \code{FractionField}
function. For example:

\begin{lstlisting}
R = FractionField(ZZ)
\end{lstlisting}

By default, Nemo makes \code{QQ = FractionField(ZZ)}, though the user can change this
assignment.

The \code{fmpq} type supports all of the functionality of the generic fraction field
section. In this section we describe additional functionality that is provided for
Flint rationals but not for general fraction fields.

\subsubsection{Constructors}

In the constructors below we assume $R$ is a Flint rational field parent object.

\begin{lstlisting}
R(a::Rational{BigInt})
\end{lstlisting}

\desc{Construct an \code{fmpq} from a Julia big rational $a$.}

One can also construct Flint rationals directly using the \code{fmpq} constructors.

\textbf{Examples.}

Here is an example of some constructors.

\begin{lstlisting}
R = FractionField(ZZ)

a = R(BigInt(1)//2)
b = fmpq(BigInt(1)//2)
\end{lstlisting}

\subsubsection{Conversions}

We provide the means to convert Flint \code{fmpz} and \code{fmpq} values to Julia
rationals.

\begin{lstlisting}
Rational(a::fmpq)
Rational(a::fmpz)
\end{lstlisting}

\desc{Return $a$ as a Julia big rational.}

\textbf{Examples.}

Here is an example of some conversions.

\begin{lstlisting}
a = Rational(fmpz(12))
b = Rational(fmpq(3, 7))
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
abs(a::fmpq)
\end{lstlisting}

\desc{Return the absolute value of the rational number $a$.}

\begin{lstlisting}
height(a::fmpq)
\end{lstlisting}

\desc{Return the height of the fraction $a$, namely the largest of the absolute
values of the numerator and denominator. The type of the return value is a 
\code{ZZ}.}

\begin{lstlisting}
height_bits(a::fmpq)
\end{lstlisting}

\desc{Return the number of bits of the height of the fraction $a$. The type of
the return value is an \code{Int}.}

\textbf{Examples.}

Here are some examples of basic manipulation.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpz(123)//234

c = abs(a)
d = height(a)
e = height_bits(b)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
isless(a::fmpq, b::fmpq) 
\end{lstlisting}

\desc{Return \code{true} if $a < b$, otherwise return \code{false}. Julia
supplies operators $<$, $>$, $\leq$ and $\geq$ from this automatically.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpz(1)//2

a < b
b >= a
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following ad hoc comparison operators are provided for convenience.

\begin{lstlisting}
==(a::fmpq, b::Int)
==(a::Int, b::fmpq)
\end{lstlisting}

\desc{Return \code{true} if $a$ is equal to $b$, otherwise return \code{false}. Julia
automatically provides \code{!=} from this.}

\begin{lstlisting}
isless(a::fmpq, b::fmpz)
isless(a::fmpq, b::Integer)
isless(a::fmpz, b::fmpq)
isless(a::Integer, b::fmpq)
\end{lstlisting}

\desc{Return \code{true} if $a < b$, otherwise return \code{false}. Julia
automatically provides corresponding functions \code{>}, \code{<=} and
\code{>=}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpz(1)//2

a < 1
a <= 0
b >= fmpz(0)
\end{lstlisting}

\subsubsection{Shifting}

\begin{lstlisting}
<<(a::fmpq, b::Int)
\end{lstlisting}

\desc{Return $a\times 2^b$.}

\begin{lstlisting}
>>(a::fmpq, b::Int)
\end{lstlisting}

\desc{Return $a/2^b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpq(1, 2)

c = a << 3
d = b >> 5
\end{lstlisting}

\subsubsection{Modular arithmetic}

\begin{lstlisting}
mod(a::fmpq, m::Integer)
mod(a::fmpq, m::fmpz)
\end{lstlisting}

\desc{If $a = p/q$ this function returns $pq^{-1} \pmod{m}$. This is only
defined if $q$ is invertible modulo $m$. The result is returned as an \code{fmpz}.}

\textbf{Examples.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpz(1)//2

c = mod(a, 7)
d = mod(b, fmpz(5))
\end{lstlisting}

\subsubsection{GCD}

Nemo defines the greatest common divisor of two rationals as the greatest rational $r$
such that both the rationals are integer multiples of $r$.

\begin{lstlisting}
gcd(a::fmpq, b::fmpq)
\end{lstlisting}

\desc{Return the greatest common divisor of $a$ and $b$.}

\subsubsection{Rational reconstruction}

\begin{lstlisting}
reconstruct(a::fmpz, m::fmpz)
reconstruct(a::fmpz, m::Integer)
reconstruct(a::Integer, m::fmpz)
reconstruct(a::Integer, m::Integer)
\end{lstlisting}

\desc{Attempt to find a rational number $n/d$ such that 
$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$ and 
$0 < d \leq \lfloor\sqrt{m/2}\rfloor$ such that gcd$(n, d) = 1$ and
$a \equiv nd^{-1} \pmod{m}$. If no solution exists, an exception is thrown.}

\textbf{Examples.}

Here are some examples of rational reconstruction.

\begin{lstlisting}
a = reconstruct(7, 13)
b = reconstruct(fmpz(15), 31)
c = reconstruct(fmpz(123), fmpz(237))
\end{lstlisting}

\subsubsection{Rational enumeration}

\begin{lstlisting}
next_minimal(x::fmpq)
\end{lstlisting}

\desc{Given $x$, returns the next rational number in the sequence obtained by
enumerating all positive denominators $q$, and for each $q$ enumerating
the numerators $1 \le p < q$ in order and generating both $p/q$ and $q/p$,
but skipping all gcd$(p,q) \neq 1$. Starting with zero, this generates
every nonnegative rational number once and only once, with the first
few entries being:

$$0, 1, 1/2, 2, 1/3, 3, 2/3, 3/2, 1/4, 4, 3/4, 4/3, 1/5, 5, 2/5, \ldots.$$

This enumeration produces the rational numbers in order of minimal height. 
It has the disadvantage of being somewhat slower to compute than the
Calkin-Wilf enumeration.

If $x < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
next_signed_minimal(x::fmpq)
\end{lstlisting}

\desc{Given a signed rational number $x$ assumed to be in canonical form, 
returns the next element in the minimal-height sequence generated by 
\code{fmpq_next_minimal} but with negative numbers interleaved:

$$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots.$$

Starting with zero, this generates every rational number once and only once,
in order of minimal height.}

\begin{lstlisting}
next_calkin_wilf(x::fmpq)
\end{lstlisting}

\desc{Given $x$ return the next number in the breadth-first traversal of the
Calkin-Wilf tree. Starting with zero, this generates every nonnegative
rational number once and only once, with the first few entries being:

$$0, 1, 1/2, 2, 1/3, 3/2, 2/3, 3, 1/4, 4/3, 3/5, 5/2, 2/5, \ldots.$$

Despite the appearance of the initial entries, the Calkin-Wilf enumeration 
does not produce the rational numbers in order of height: some small fractions
will appear late in the sequence. This order has the advantage of being faster 
to produce than the minimal-height order.}

\begin{lstlisting}
next_signed_calkin_wilf(x::fmpq)
\end{lstlisting}

\desc{Given a signed rational number $x$ returns the next element in the
Calkin-Wilf sequence with negative numbers interleaved:

$$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots.$$

Starting with zero, this generates every rational number once and only once,
but not in order of minimal height.}

\textbf{Examples.}

Here are some examples of rational enumeration.

\begin{lstlisting}
next_minimal(fmpz(2)//3)
next_signed_minimal(-fmpz(21)//31)
next_calkin_wilf(fmpz(321)//113)
next_signed_calkin_wilf(-fmpz(51)//(17))
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
harmonic(n::Int)
\end{lstlisting}

\desc{Computes the harmonic number $H_n = 1 + 1/2 + 1/3 + \cdots + 1/n$.
Table lookup is used for $H_n$ whose numerator and denominator 
fit in a single limb. For larger $n$, a divide and conquer strategy is used.}

\begin{lstlisting}
dedekind_sum(h::fmpz, k::fmpz)
dedekind_sum(h::fmpz, k::Integer)
dedekind_sum(h::Integer, k::fmpz)
dedekind_sum(h::Integer, k::Integer)
\end{lstlisting}

\desc{Computes the Dedekind sum $s(h,k)$ for arbitrary $h$ and $k$.}

\textbf{Examples.}

Here are some examples of special functions.

\begin{lstlisting}
a = harmonic(12)

b = dedekind_sum(12, 13)
c = dedekind_sum(-120, fmpz(1305))
\end{lstlisting}

\subsection{Flint finite fields $\F_{p^k}$ (multiprecision $p$): \code|fq|}

We allow the construction of finite fields of any characteristic and degree in
Nemo. When a Conway polynomial is known, the field is generated using the 
Conway polynomial. Otherwise a random sparse, irreducible polynomial is used. 

(At this stage we make no attempt to compatibly embed finite fields generated 
using randomly chosen irreducible polynomials, such as with the 
Bosma-Cannon-Steel construction. But this may change in a later version of 
Flint/Nemo.) 

The Flint type for finite fields $\F_{p^k}$ for multiprecision $p$ is
\code{fq}.

The type of elements of Flint \code{fq} fields in Nemo is \code{fq}.
This type belongs to the \code{FiniteFieldElem} type class, which in turn belongs
to the \code{FieldElem} class. The type of the parent object for such fields is
\code{FqFiniteField} which belongs to the \code{Field} type class.

The parent object for such a field is created using the \code{FiniteField}
function, e.g.

\begin{lstlisting}
FiniteField(p::fmpz, deg::Int, var::String)
\end{lstlisting}

\desc{Return a tuple \code{(R, x)} consisting of the parent object \code{R} of
a finite field of characteristic \code{p} of degree \code{deg}, and a
generator \code{x}. 

The generator \code{x} of the field will be printed as the provided string
\code{var}. The characteristic \code{p} must be prime, but we do not check this
condition. The degree \code{deg} must be nonnegative. If \code{deg} is negative
we throw a \code{DomainError()}.}

For example, the following code generates a parent object for the finite field
of characteristic $7$ and degree $5$ (defined by a Conway polynomial).

\begin{lstlisting}
S, x = FiniteField(fmpz(7), 5, "x")
\end{lstlisting}

\subsubsection{Constructors}

Elements of the finite field \code{R} can be constructed as polynomials of
degree less than \code{deg} in \code{x}. As usual we overload the parent object
for the finite field to construct elements of the field.

In the constructors below, we take $S$ to be a parent object of a finite field
as given by the construction above, for example.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Return the element $0$ of the finite field.}

\begin{lstlisting}
S(a::Int)
S(a::Integer)
S(a::fmpz)
\end{lstlisting}

\desc{Return the element \code{a} of the finite field, where $a$ is considered 
an element of $\F_p$.}

\begin{lstlisting}
S(a::fq)
\end{lstlisting}

\desc{Return a reference to the element \code{a} of the finite field. No copy
of the data is made by this function.}

\textbf{Examples.}

Here are some examples of constructing finite fields and elements in them.

\begin{lstlisting}
S, y = FiniteField(fmpz(17), 3, "y")

f = 2y^2 + 11y + 16

g = S(4)
h = S()
k = S(g)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
zero(R::FqFiniteField)
\end{lstlisting}

\desc{Return the additive identity in the finite field, i.e. $0$.}

\begin{lstlisting}
one(R::FqFiniteField)
\end{lstlisting}

\desc{Return the multiplicative identity in the finite field, i.e. $1$.}

\begin{lstlisting}
gen(R::FqFiniteField)
\end{lstlisting}

\desc{Return a generator of the finite field, namely one whose
representation is the monomial of degree $1$ modulo the defining
polynomial of the field. The generator is guaranteed to be a multiplicative 
generator only if the field is generated by a Conway polynomial.}

\begin{lstlisting}
iszero(a::fq)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the additive identity in the
finite field, i.e. if it is $0$, otherwise return \code{false}.}

\begin{lstlisting}
isone(a::fq)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the multiplicative identity in
the finite field, i.e. if it is $1$, otherwise return \code{false}.}

\begin{lstlisting}
isgen(a::fq)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the generator of the finite field,
otherwise return \code{false}.}

\begin{lstlisting}
isunit(a::fq)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is invertible in the finite field,
i.e. if it is not zero, otherwise return \code{false}.}

\begin{lstlisting}
characteristic(R::FqFiniteField)
\end{lstlisting}

\desc{Return the prime characteristic $p$ of the finite field as a bignum
\code{ZZ}.}

\begin{lstlisting}
order(R::FqFiniteField)
\end{lstlisting}

\desc{Return the number of elements in the finite field, i.e. $q = p^d$
where \code{p} is the characteristic and $d$ is the degree.}

\begin{lstlisting}
degree(R::FqFiniteField)
\end{lstlisting}

\desc{If the finite field is $\F_q$ where $q = p^d$, where $p$ is the
prime characteristic of the field, this function returns the degree
$d$.}

\begin{lstlisting}
coeff(a::fq, n::Int)
\end{lstlisting}

\desc{Return the coefficient of degree $n$ in the polynomial representation
of the element $a$ of the finite field. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
deepcopy(a::fq)
\end{lstlisting}

\desc{Return a new finite field element which is arithmetically equal to
the given element.}

\begin{lstlisting}
canonical_unit(a::fq)
\end{lstlisting}

\desc{Used for canonicalising fractions. Simply returns $a$.}

\textbf{Examples.}

Here are some examples of basic manipulations of finite fields.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = zero(R)
b = one(R)
c = gen(R)
d = characteristic(R)
f = order(R)
g = degree(R)
h = iszero(a)
k = isone(b)
m = isunit(x + 1)
n = deepcopy(c)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-(a::fq)
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = -a
\end{lstlisting}

\subsubsection{Binary operators}

We provide the following binary operators for elements of
finite fields.

\begin{lstlisting}
+(a::fq, b::fq)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fq, b::fq)
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*(a::fq, b::fq)
\end{lstlisting}

\desc{Return $ab$.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + x + 1

c = a + b
d = a - b
f = a*b
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

We provide the following ad hoc binary operators, which are faster than first
coercing all their arguments into the finite field.

\begin{lstlisting}
*(x::Int, y::fq)
*(x::Integer, y::fq)
*(x::fmpz, y::fq)
\end{lstlisting}

\desc{Return $xy$, i.e. $y$ added to itself $x$ times.}

\begin{lstlisting}
*(x::fq, y::Int)
*(x::fq, y::Integer)
*(x::fq, y::fmpz)
\end{lstlisting}

\desc{Return $xy$, i.e. $x$ added to itself $y$ times.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = 3a
c = a*fmpz(5)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^(a::fq, n::Int)
^(a::fq, n::fmpz)
\end{lstlisting}

\desc{Return $a^n$.}

\textbf{Examples.}

Here are some examples of powering of finite field elements.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = a^3
c = a^fmpz(-5)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
==(a::fq, b::fq)
\end{lstlisting}

\desc{Return \code{true} if the finite field elements $a$ and $b$ are 
arithmetically equal, otherwise return \code{false}.}

Julia automatically provides corresponding \code{!=} functionality.

\textbf{Examples.}

Here are some examples of comparison of finite field elements.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

b != a
R(3) == R(3)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv(a::fq)
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$ in the finite field, i.e. 
$a^{-1}$ such that $aa^{-1} = 1$ in the finite field.}

\textbf{Examples.}

Here are some examples of inversion of finite field elements.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = inv(a)
b == a^-1
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(x::fq, y::fq)
//(x::fq, y::fq)
\end{lstlisting}

\desc{Return $x/y$, which is an exact division in a finite field when defined,
since every nonzero element is invertible. We throw a \code{DivideError()} if
$y = 0$. Both forms of exact division are the same, one being a synonym for 
the other.}

\textbf{Examples.}

Here are some examples of exact division of finite field elements.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

c = divexact(a, b)
d = b//a
\end{lstlisting}

\subsubsection{GCD}

\begin{lstlisting}
gcd(a::fq, b::fq)
\end{lstlisting}

\desc{Return gcd$(a, b)$. For a finite field this is always $1$ unless both
$a$ and $b$ are $0$, in which case the gcd is $0$.}

\textbf{Examples.}

Here are some examples of GCD.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + x + 1

c = gcd(a, b)
d = gcd(R(0), R(0))
\end{lstlisting}

\subsubsection{Special functions}

Various special functions with finite field specific behaviour are
defined.

\begin{lstlisting}
trace(a::fq)
\end{lstlisting}

\desc{Return the trace of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
norm(a::fq)
\end{lstlisting}

\desc{Return the norm of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
frobenius(a::fq, n = 1)
\end{lstlisting}

\desc{Return the iterated Frobenius $\sigma_p^n(a)$ where $\sigma_p$ is the 
Frobenius map sending the element $a$ to $a^p$ in the finite field of 
characteristic $p$. By default the Frobenius map is applied $n = 1$ times if
$n$ is not specified.}

\begin{lstlisting}
pth_root(a::fq)
\end{lstlisting}

\desc{Return the $p$-th root of $a$ in the finite field of characteristic
$p$. This is the inverse operation to the Frobenius map $\sigma_p$.}

\textbf{Examples.}

Here are some examples of special finite field functionality.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = trace(a)
c = norm(a)
d = frobenius(a)
f = frobenius(a, 3)
g = pth_root(a)
\end{lstlisting}

\subsection{Flint finite fields $\F_{p^k}$ (small $p$): \code|fq_nmod|}

The Flint type for finite fields $\F_{p^k}$ for $p$ that fits in a single machine
word is \code{fq_nmod}.

When a Conway polynomial is known, such a field is generated using the 
Conway polynomial. Otherwise a random sparse, irreducible polynomial is used. 

The type of elements of Flint \code{fq_nmod} fields in Nemo is \code{fq_nmod}.
This type belongs to the \code{FiniteFieldElem} type class, which in turn belongs
to the \code{FieldElem} class. The type of the parent object for such fields is
\code{FqNmodFiniteField} which belongs to the \code{Field} type class.

The parent object for such a field is created using the \code{FiniteField}
function, e.g.

\begin{lstlisting}
FiniteField(p::Int, deg::Int, var::String)
\end{lstlisting}

\desc{Return a tuple \code{(R, x)} consisting of the parent object \code{R} of
a finite field of characteristic \code{p} of degree \code{deg}, and a
generator \code{x}. 

The generator \code{x} of the field will be printed as the provided string
\code{var}. The characteristic \code{p} must be prime, but we do not check this
condition. The degree \code{deg} must be nonnegative. If \code{deg} is negative
we throw a \code{DomainError()}.}

For example, the following code generates a parent object for the finite field
of characteristic $7$ and degree $5$ (defined by a Conway polynomial).

\begin{lstlisting}
S, x = FiniteField(7, 5, "x")\end{lstlisting}

\subsubsection{Constructors}

Elements of the finite field \code{R} can be constructed as polynomials of
degree less than \code{deg} in \code{x}. As usual we overload the parent object
for the finite field to construct elements of the field.

In the constructors below, we take $S$ to be a parent object of a finite field
as given by the construction above, for example.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Return the element $0$ of the finite field.}

\begin{lstlisting}
S(a::Int)
S(a::Integer)
S(a::fmpz)
\end{lstlisting}

\desc{Return the element \code{a} of the finite field, where $a$ is considered 
an element of $\F_p$.}

\begin{lstlisting}
S(a::fq_nmod)
\end{lstlisting}

\desc{Return a reference to the element \code{a} of the finite field. No copy
of the data is made by this function.}

\textbf{Examples.}

Here are some examples of constructing finite fields and elements in them.

\begin{lstlisting}
S, y = FiniteField(17, 3, "y")

f = 2y^2 + 11y + 16

g = S(4)
h = S()
k = S(g)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
zero(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return the additive identity in the finite field, i.e. $0$.}

\begin{lstlisting}
one(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return the multiplicative identity in the finite field, i.e. $1$.}

\begin{lstlisting}
gen(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return a generator of the finite field, namely one whose
representation is the monomial of degree $1$ modulo the defining
polynomial of the field. The generator is guaranteed to be a multiplicative 
generator only if the field is generated by a Conway polynomial.}

\begin{lstlisting}
iszero(a::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the additive identity in the
finite field, i.e. if it is $0$, otherwise return \code{false}.}

\begin{lstlisting}
isone(a::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the multiplicative identity in
the finite field, i.e. if it is $1$, otherwise return \code{false}.}

\begin{lstlisting}
isgen(a::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the generator of the finite field,
otherwise return \code{false}.}

\begin{lstlisting}
isunit(a::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is invertible in the finite field,
i.e. if it is not zero, otherwise return \code{false}.}

\begin{lstlisting}
characteristic(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return the prime characteristic $p$ of the finite field as a bignum
\code{ZZ}.}

\begin{lstlisting}
order(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return the number of elements in the finite field, i.e. $q = p^d$
where \code{p} is the characteristic and $d$ is the degree.}

\begin{lstlisting}
degree(R::FqNmodFiniteField)
\end{lstlisting}

\desc{If the finite field is $\F_q$ where $q = p^d$, where $p$ is the
prime characteristic of the field, this function returns the degree
$d$.}

\begin{lstlisting}
coeff(a::fq_nmod, n::Int)
\end{lstlisting}

\desc{Return the coefficient of degree $n$ in the polynomial representation
of the element $a$ of the finite field. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
deepcopy(a::fq_nmod)
\end{lstlisting}

\desc{Return a new finite field element which is arithmetically equal to
the given element.}

\begin{lstlisting}
canonical_unit(a::fq_nmod)
\end{lstlisting}

\desc{Used for canonicalising fractions. Simply returns $a$.}

\textbf{Examples.}

Here are some examples of basic manipulations of finite fields.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = zero(R)
b = one(R)
c = gen(R)
d = characteristic(R)
f = order(R)
g = degree(R)
h = iszero(a)
k = isone(b)
m = isunit(x + 1)
n = deepcopy(c)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-(a::fq_nmod)
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = -a
\end{lstlisting}

\subsubsection{Binary operators}

We provide the following binary operators for elements of
finite fields.

\begin{lstlisting}
+(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return $ab$.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + x + 1

c = a + b
d = a - b
f = a*b
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

We provide the following ad hoc binary operators, which are faster than first
coercing all their arguments into the finite field.

\begin{lstlisting}
*(x::Int, y::fq_nmod)
*(x::Integer, y::fq_nmod)
*(x::fmpz, y::fq_nmod)
\end{lstlisting}

\desc{Return $xy$, i.e. $y$ added to itself $x$ times.}

\begin{lstlisting}
*(x::fq_nmod, y::Int)
*(x::fq_nmod, y::Integer)
*(x::fq_nmod, y::fmpz)
\end{lstlisting}

\desc{Return $xy$, i.e. $x$ added to itself $y$ times.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1

b = 3a
c = a*fmpz(5)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^(a::fq_nmod, n::Int)
^(a::fq_nmod, n::fmpz)
\end{lstlisting}

\desc{Return $a^n$.}

\textbf{Examples.}

Here are some examples of powering of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1

b = a^3
c = a^fmpz(-5)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
==(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the finite field elements $a$ and $b$ are 
arithmetically equal, otherwise return \code{false}.}

Julia automatically provides corresponding \code{!=} functionality.

\textbf{Examples.}

Here are some examples of comparison of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

b != a
R(3) == R(3)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv(a::fq_nmod)
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$ in the finite field, i.e. 
$a^{-1}$ such that $aa^{-1} = 1$ in the finite field.}

\textbf{Examples.}

Here are some examples of inversion of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1

b = inv(a)
b == a^-1
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(x::fq_nmod, y::fq_nmod)
//(x::fq_nmod, y::fq_nmod)
\end{lstlisting}

\desc{Return $x/y$, which is an exact division in a finite field when defined,
since every nonzero element is invertible. We throw a \code{DivideError()} if
$y = 0$. Both forms of exact division are the same, one being a synonym for 
the other.}

\textbf{Examples.}

Here are some examples of exact division of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

c = divexact(a, b)
d = b//a
\end{lstlisting}

\subsubsection{GCD}

\begin{lstlisting}
gcd(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return gcd$(a, b)$. For a finite field this is always $1$ unless both
$a$ and $b$ are $0$, in which case the gcd is $0$.}

\textbf{Examples.}

Here are some examples of GCD.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + x + 1

c = gcd(a, b)
d = gcd(R(0), R(0))
\end{lstlisting}

\subsubsection{Special functions}

Various special functions with finite field specific behaviour are
defined.

\begin{lstlisting}
trace(a::fq_nmod)
\end{lstlisting}

\desc{Return the trace of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
norm(a::fq_nmod)
\end{lstlisting}

\desc{Return the norm of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
frobenius(a::fq_nmod, n = 1)
\end{lstlisting}

\desc{Return the iterated Frobenius $\sigma_p^n(a)$ where $\sigma_p$ is the 
Frobenius map sending the element $a$ to $a^p$ in the finite field of 
characteristic $p$. By default the Frobenius map is applied $n = 1$ times if
$n$ is not specified.}

\begin{lstlisting}
pth_root(a::fq_nmod)
\end{lstlisting}

\desc{Return the $p$-th root of $a$ in the finite field of characteristic
$p$. This is the inverse operation to the Frobenius map $\sigma_p$.}

\textbf{Examples.}

Here are some examples of special finite field functionality.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1

b = trace(a)
c = norm(a)
d = frobenius(a)
f = frobenius(a, 3)
g = pth_root(a)
\end{lstlisting}

\subsection{The p-adics}

We define a parametric type \code{Padic} to contain elements of the $p$-adic
numbers in Nemo. As usual, the user need not know the details of the type, as
we define a function \code{PadicField} for constructing it.

We describe here the internals of the \code{Padic} type, but the reader may
skip ahead to the section on constructors if so desired.

The \code{Padic} type takes a single parameter \code{S}, which is a symbol.
This symbol is the name of a variable which contains, amongst other things,
the prime $p$ for the $p$-adic type.

The first part of the \code{Padic} type in Nemo mirrors the internals of the
flint \code{padic_t} type. Here is its definition.

\begin{lstlisting}
type Padic{S} <: Field
   u :: Int 
   v :: Int
   N :: Int
   exact :: Bool
end
\end{lstlisting}

The \code{u}, \code{v} and \code{N} fields correspond to the $p$-adic unit
(actually of type \code{fmpz} in flint), the valuation and precision
respectively. 

There is one additional field, called \code{exact}. We use this to specify
when a $p$-adic number is exact (i.e. when it exactly represents a rational
number with denominator a power of $p$). We require this because of the way
flint handles $p$-adic precision.

The flint $p$-adic interface ignores the precision of inputs to its $p$-adic
functions and only pays attention to the desired precision as set in the
output(s). We modify this behaviour in Nemo by computing on-the-fly the best
possible output precision given the input precisions. We then use this for the
required output precision when calling flint.

However, the flint $p$-adic type has no way to specify an infinite precision
output, e.g. when the input precisions are in fact known exactly. The
additional \code{exact} field in the Nemo type allows us to handle such cases
specially.

Flint does provide some functions which ignore the specified output precision,
interpreting the result as exact. We use these in combination with the Nemo
\code{exact} field to provide operations on infinite precision $p$-adics.

There is also a flint \code{padic_ctx_t} type which is mirrored in a Julia
\code{padic_ctx} type. As the details are not important we omit the definition
here. It is this \code{padic_ctx} that is attached to the symbol \code{S} on
which the Nemo \code{Padic} type is parameterised.

\subsubsection{Constructors}

We provide the following simple function for creating the type of the $p$-adic
numbers.

\begin{lstlisting}
PadicField(p::Int)
PadicField(p::ZZ)
\end{lstlisting}

\desc{This function returns a type corresponding to the $p$-adic numbers for
the given prime $p$. We test that $p$ is actually prime before constructing
the type. If not, an exception is thrown.}

No default precision is used for the $p$-adic type in Nemo. Elements can be
constructed with any desired precision and the results of computations are
computed to the best possible output precision given the precision of the
inputs. 

This includes the possibility of infinite precision in the case of exact
rational values with a power of the prime $p$ as denominator. Nemo will throw
an exception if an output value has infinite precision in theory but which
cannot be represented exactly due to requiring infinite space (e.g. negative
integers or fractions with something other than a power of $p$ as denominator).

To construct values of $p$-adic type we use the \code{O} operator. It requires
the $p$-adic type as a parameter for reasons of type soundness and so that
expressions such as $O(7^0)$ can be entered unambiguously (as \code{O(R, 7^0)},
say).

\begin{lstlisting}
O{S}(::Type{Padic{S}}, m::Int)
O{S}(::Type{Padic{S}}, m::ZZ)
O{S}(::Type{Padic{S}}, m::QQ)
\end{lstlisting}

\desc{Construct the value $0 + O(p^n)$ given $m = p^n$. An exception results
if $m$ is not found to be a power of \code{p = prime(Padic{S})}.}

The \code{O(p^n)} construction can be used to construct $p$-adic values of
precision $n$ by adding it to integer values representing the $p$-adic value
modulo $p^n$. See the examples below for details.

\begin{lstlisting}
Padic{S}()
\end{lstlisting}

\desc{Construct the $p$-adic value $0$ with precision $0$, i.e. $0 + O(p^0)$.}

\begin{lstlisting}
Padic{S}(a::Int)
Padic{S}(a::ZZ)
Padic{S}(a::QQ)
\end{lstlisting}

\desc{Construct the exact (infinite precision) $p$-adic value representing the
integer or rational $a$. An exception will result if $a < 0$ or if the 
denominator of $a$ is not a power of $p$.}

\textbf{Examples.}

Here are some examples of constructing $p$-adics.

\begin{lstlisting}
R = PadicField(7)
S = PadicField(ZZ(65537))

a = R()
b = R(1)
c = R(ZZ(123))
d = R(ZZ(1)/7^2)

f = 1 + 2*7 + 4*7^2 + O(R, 7^3)
g = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)
h = ZZ(1)/7^2 + ZZ(2)/7 + 3 + 4*7 + O(R, 7^2)
\end{lstlisting}

Beware that the expression \code{1 + 2*p + 3*p^2 + O(R, p^n)} is actually computed as
a normal Julia expression. Therefore if \code{Int} values are used instead of
\code{ZZ}'s, overflow may result in evaluating the value.

Also note that one cannot use \code{7^-2} in a $p$-adic expression, since the 
exponentiation operator must always return an integer, for reasons of type soundness.

\subsubsection{Basic manipulation}

\begin{lstlisting}
prime{S}(::Type{Padic{S}})
\end{lstlisting}

\desc{Return the prime $p$ on which the $p$-adic type is based. The returned
value is of type \code{ZZ}.}

\begin{lstlisting}
precision{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the precision of the given $p$-adic value, e.g. the precision of
$1 + 7 + 2*7^2 + O(7^3)$ is $3$. The precision is meaningless for an
exact value.}

\begin{lstlisting}
valuation{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the $p$-adic valuation of the given $p$-adic value.}

\begin{lstlisting}
isexact{S}(a::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if the given $p$-adic value is exact, i.e. infinite
precision, otherwise return \code{false}.}

\begin{lstlisting}
zero{S}(::Type{Padic{S}})
\end{lstlisting}

\desc{Return the additive identity, i.e. exact $0$ in the field of $p$-adic
numbers.}

\begin{lstlisting}
one{S}(::Type{Padic{S}})
\end{lstlisting}

\desc{Return the multiplicative identity, i.e. exact $1$ in the field of
$p$-adic numbers.}

\begin{lstlisting}
iszero{S}(a::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if the given $p$-adic value is the additive identity,
i.e. exact $0$, otherwise return \code{false}.}

\begin{lstlisting}
isone{S}(a::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if the given $p$-adic value is the multiplicative
identity, i.e. exact $1$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of basic manipulations of $p$-adics.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 7^2 + 3*7^3 + O(R, 7^5)
c = R(2)

d = one(R)
f = zero(R)
g = isone(d)
h = iszero(f)
k = isexact(c)
n = precision(a)
p = prime(R)
v = valuation(b)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{S}(x::Padic{S})
\end{lstlisting}

\desc{Return $-x$. Note that if $x$ is for example a positive integer
represented exactly, then $-x$ may not be representable exactly as a $p$-adic.
In this case an exception is raised.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = R(0)

c = -a
d = -b
\end{lstlisting}

\subsubsection{Binary operators}

\begin{lstlisting}
+{S}(x::Padic{S}, y::Padic{S})
\end{lstlisting}

\desc{Return $x + y$. The output precision will be the least of the input
precisions.}

\begin{lstlisting}
-{S}(x::Padic{S}, y::Padic{S})
\end{lstlisting}

\desc{Return $x - y$. The output precision will be the least of the input
precisions. Note that if $x$ and $y$ are exact and $x - y$ cannot be
represented exactly, an exception will be raised.}

\begin{lstlisting}
*{S}(x::Padic{S}, y::Padic{S})
\end{lstlisting}

\desc{Return $xy$. The output precision will be the least of valuation$(x) +$
precision$(y)$ and precision$(x) +$ valuation$(y)$.}

\textbf{Examples.}

Here are some examples of binary operators for $p$-adics.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 7^2 + 3*7^3 + O(R, 7^5)
c = O(R, 7^3)
d = R(2)

f = a + b
g = a - b
h = a*b
j = b*c
k = a*d
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
+{S}(x::Padic{S}, y::Int)
+{S}(x::Padic{S}, y::ZZ)
+{S}(x::Padic{S}, y::QQ)
\end{lstlisting}

\desc{Return $x + y$ where $y$ is interpreted as an exact $p$-adic value. If
the result is unrepresentable, an exception results.}

\begin{lstlisting}
+{S}(x::Int, y::Padic{S})
+{S}(x::ZZ, y::Padic{S})
+{S}(x::QQ, y::Padic{S})
\end{lstlisting}

\desc{Return $x + y$ where $x$ is interpreted as an exact $p$-adic value. If
the result is unrepresentable, an exception results.}

\begin{lstlisting}
-{S}(x::Padic{S}, y::Int)
-{S}(x::Padic{S}, y::ZZ)
-{S}(x::Padic{S}, y::QQ)
\end{lstlisting}

\desc{Return $x - y$ where $y$ is interpreted as an exact $p$-adic value. If
the result is unrepresentable, an exception results.}

\begin{lstlisting}
-{S}(x::Int, y::Padic{S})
-{S}(x::ZZ, y::Padic{S})
-{S}(x::QQ, y::Padic{S})
\end{lstlisting}

\desc{Return $x - y$ where $x$ is interpreted as an exact $p$-adic value. If
the result is unrepresentable, an exception results.}

\begin{lstlisting}
*{S}(x::Padic{S}, y::Int)
*{S}(x::Padic{S}, y::ZZ)
*{S}(x::Padic{S}, y::QQ)
\end{lstlisting}

\desc{Return $xy$. If $y$ is negative or the result is not representable, an
exception results.}

\begin{lstlisting}
*{S}(x::Int, y::Padic{S})
*{S}(x::ZZ, y::Padic{S})
*{S}(x::QQ, y::Padic{S})
\end{lstlisting}

\desc{Return $xy$. If $x$ is negative or the result is not representable, an 
exception results.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 7^2 + 3*7^3 + O(R, 7^5)
c = O(R, 7^3)
d = R(2)

f = a + 2
g = 3 - b
h = a*ZZ(5)
j = ZZ(3)*c
k = 2*d
l = 2 + d
m = d - ZZ(2)
n = a + ZZ(1)/7^2
p = (ZZ(12)/11)*b
q = c*(ZZ(1)/7)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={S}(a::Padic{S}, b::Padic{S})
\end{lstlisting}

\desc{Compare the given $p$-adic values at the least of the two precisions and
return \code{true} if they are equal to that precision, otherwise return
\code{false}. With this definition \code{0 == 0 + O(7^3)} returns
\code{true}. If one wishes to compare with exact $0$, one should use
\code{iszero}.}

Julia automatically supplies a corresponding \code{!=} operator.

\begin{lstlisting}
isequal{S}(a::Padic{S}, b::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if \code{a == b} and if they are either both exact or
if the precisions are the same, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 3*7^3 + O(R, 7^5)
c = O(R, 7^3)
d = R(2)

a == 1 + 2*7 + O(R, 7^2)
b == c
c == R(0)
d == R(2)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following ad hoc comparison operators are provided for convenience. They
allow comparison with exact values (up to the precision of the $p$-adic value
supplied).

\begin{lstlisting}
=={S}(a::Padic{S}, b::Int)
=={S}(a::Padic{S}, b::ZZ)
=={S}(a::Padic{S}, b::QQ)
\end{lstlisting}

\desc{Return \code{true} if the exact value $b$ is equal to the $p$-adic 
value $a$ up to the precision of $a$, otherwise return \code{false}.}

\begin{lstlisting}
=={S}(a::Int, b::Padic{S})
=={S}(a::ZZ, b::Padic{S})
=={S}(a::QQ, b::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if the exact value $a$ is equal to the $p$-adic 
value $b$ up to the precision of $b$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
R = PadicField(7)

a = 1 + O(R, 7^3)
b = O(R, 7^5)
c = R(2)

a == 1
b == ZZ(0)
c == 2
ZZ(2) == c
a == ZZ(344)/1
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{S}(a::Padic{S}, n::Int)
\end{lstlisting}

\desc{Return $a^n$. The output precision will be the same as if $a$ had been
multiplied by itself $n$ times, i.e. precision$(a) + (n - 1)\times$
valuation$(a)$. If the input is exact and $n \geq 0$ the output will be
exact. If $n < 0$ and $a$ is exact, it may be that the output is not
representable. In such cases an exception is raised.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = O(R, 7^5)
c = R(2)

d = a^5
f = b^3
g = c^7
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{S}(a::Padic{S}, b::Padic{S})
/{S}(a::Padic{S}, b::Padic{S})
\end{lstlisting}

\desc{Return $a/b$. The output precision will be the minimum of 
precision$(a) -$ valuation$(b)$ and precision$(b) - 2\times$valuation$(b) +$
valuation$(a)$. If the result is not representable, an exception is
thrown. If \code{b == 0} a \code{DivideError()} is thrown.}

\begin{lstlisting}
divexact{S}(a::Padic{S}, b::Int)
divexact{S}(a::Padic{S}, b::ZZ)
divexact{S}(a::Padic{S}, b::QQ)
/{S}(a::Padic{S}, b::Int)
/{S}(a::Padic{S}, b::ZZ)
/{S}(a::Padic{S}, b::QQ)
\end{lstlisting}

\desc{Return $a/b$. The output precision will be precision$(a) -$ 
valuation$(b)$. If the result is not representable, an exception is
thrown. If \code{b == 0} a \code{DivideError()} is thrown.}

\begin{lstlisting}
divexact{S}(a::Int, b::Padic{S})
divexact{S}(a::ZZ, b::Padic{S})
divexact{S}(a::QQ, b::Padic{S})
/{S}(a::Int, b::Padic{S})
/{S}(a::ZZ, b::Padic{S})
/{S}(a::QQ, b::Padic{S})
\end{lstlisting}

\desc{Return $a/b$. The output precision will be 
precision$(b) - 2\times$valuation$(b) +$ valuation$(a)$. If the result is not
representable, an exception is thrown. If \code{b == 0} a \code{DivideError()}
is thrown.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)
d = 7 + 2*7^2 + O(R, 7^5)

f = divexact(a, b)
g = divexact(c, d)
h = divexact(d, R(7^3))
j = divexact(R(34), R(17))

k = a/2
l = b/ZZ(7)
m = c/(ZZ(12)/7^2)
n = 2/d
p = R(3)/3
q = (ZZ(5)/7)/R(5)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$, i.e. $1/a$. If \code{a == 0}
a \code{DivideError()} is thrown. If the result is not representable, an
exception is thrown.}

\textbf{Examples.}

Here are some examples of inversion.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)
d = 7 + 2*7^2 + O(R, 7^5)

f = inv(a)
g = inv(b)
h = inv(c)
k = inv(d)
l = inv(R(1))
\end{lstlisting}

\subsubsection{Square root}

\begin{lstlisting}
sqrt{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the $p$-adic square root of $a$. We define this only when the
valuation of $a$ is even. The precision of the output will be precision$(a) -$
valuation$(a)/2$. If the square root does not exist or is unrepresentable, an
exception is thrown.}

\textbf{Examples.}

Here are some examples of taking a $p$-adic square root.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)

d = sqrt(a)
f = sqrt(b)
f = sqrt(c)
g = sqrt(R(121))
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
exp{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the $p$-adic exponential of $a$. We define this only when the
valuation of $a$ is positive (unless \code{a == 0}). The precision of the
output will be the same as the precision of the input. If the result is not
representable an exception is thrown.}

\begin{lstlisting}
log{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the $p$-adic logarithm of $a$. We define this only when the
valuation of $a$ is zero (but not for \code{a == 0}). The precision of the
output will be the same as the precision of the input. If the result is not
representable an exception is thrown.}

\begin{lstlisting}
teichmuller{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the Teichmuller lift of the $p$-adic value $a$. We require the
valuation of $a$ to be nonnegative. The precision of the output will be the
same as the precision of the input. For convenience, if $a$ is congruent to
zero modulo $p$ we return zero. If the result is not representable an
exception is thrown.}

\textbf{Examples.}

Here are some examples of special functions.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 5*7 + 3*7^2 + O(R, 7^3)
c = 3*7 + 2*7^2 + O(R, 7^5)

c = exp(c)
d = log(a)
c = exp(R(0))
d = log(R(1))
f = teichmuller(b) 
\end{lstlisting}

\end{document}
